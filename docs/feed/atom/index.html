<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="english"><id>/</id><title>Yuan's Blog</title><updated>2025-05-16T22:33:17.022032+08:06</updated><author><name>Yuan</name><email>im.wuxiaoyuan@gmail.com</email></author><link href="/" rel="alternate"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><logo>/android-chrome-512x512.png</logo><subtitle>Hello, World!</subtitle><entry><id>/archives/quartz-plus/</id><title>quartz-plus</title><updated>2025-05-16T14:33:17.022194+00:00</updated><author><name>wuxiaoyuan</name><email>im.wuxiaoyuan@gmail.com</email><uri>https://tripleyuan.github.io/</uri></author><content>&lt;p&gt;在工作中，我经常会使用到 Quartz，一个开源的分布式任务调度框架。然而，尽管 Quartz 提供了强大的功能，我在使用过程中却遇到了一些痛点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Quartz 不支持注解的方式定义Job，这导致我们只能通过硬编码的方式创建&lt;code&gt;Job&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;，并手动注册到 Quartz scheduler 中。&lt;/li&gt;
&lt;li&gt;Quartz 未提供任务调度管理界面。在实际工作中，我常常需要手动触发某个Job的执行，然而由于缺少管理页面，我们只能通过修改数据库中 trigger 的执行时间来间接触发 job 的执行，这显然不是一个高效的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这些问题，提高开发效率，我基于 Spring 对 Quartz 进行了扩展，开发了一个名为 Quartz Plus 的工具库：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;支持注解的方式快速定义&lt;code&gt;Job&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;：使用 @QuartzJob 和 @QuartzTrigger 注解，我们可以快速地定义&lt;code&gt;Job&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;，并且它们会自动注册到&lt;code&gt;Quartz Scheduler&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;实现了一个带有管理界面的 Quartz 任务调度中心：该任务调度中心提供了完整的管理界面，包括 job 管理、Quartz 实例管理、用户管理等功能，使我们能够更方便地管理和监控任务调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目源码地址：&lt;a href="https://github.com/TripleYuan/quartz-plus.git"&gt;https://github.com/TripleYuan/quartz-plus.git&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;快速上手&lt;/h2&gt;
&lt;h3&gt;部署Quartz任务调度系统&lt;/h3&gt;
&lt;p&gt;调度系统分为前端和后端两个项目，可以分开部署 &lt;strong&gt;quartz-plus-scheduler-center&lt;/strong&gt;（调度服务） 和 &lt;strong&gt;quartz-plus-web-console&lt;/strong&gt;（前端应用），也可将前端代码打包后的静态资源文件集成到 &lt;code&gt;quartz-plus-scheduler-center&lt;/code&gt; 中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;quartz-plus-scheduler-center&lt;/code&gt; 默认使用的是H2数据库，生产环境建议使用外部数据库，如 MySQL、PostgreSQL 等。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;系统内置了两个登录用户：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;用户1：用户名为 admin，密码为 123456，拥有管理员权限。&lt;/p&gt;&lt;p&gt;用户2：用户名为 quartz，密码为 123456，仅具有普通用户权限。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3&gt;SpringBoot应用接入&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;引入最新版本&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;redcoder&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;quartz-plus-core&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${quartzplus.latest.version}&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol start="2"&gt;
&lt;li&gt;在启用类上添加注解 &lt;code&gt;@QuartzJobScan&lt;/code&gt;，并指定 job 类所在的包路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class="nd"&gt;@QuartzJobScan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;redcoder.quartzplus.demo.job&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;QuartzPlusDemoApplication&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;SpringApplication&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QuartzPlusDemoApplication&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol start="3"&gt;
&lt;li&gt;添加配置，指定注册中心服务地址&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;quartz-job-scheduler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;registry&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;# 调度服务注册地址（替换成你的IP和端口）&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;register-url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;http://localhost:32007/api/quartz-job-scheduler/instance/register&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;# 调度服务取消注册地址（替换成你的IP和端口）&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;unregister-url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;http://localhost:32007/api/quartz-job-scheduler/instance/unregister&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;注解式定义Job和Trigger&lt;/h3&gt;
&lt;p&gt;使用 &lt;strong&gt;@QuartzJob&lt;/strong&gt; 和 &lt;strong&gt;@QuartzTrigger&lt;/strong&gt; 注解快速定义 &lt;code&gt;Job&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@QuartzJob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;打印 hello world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@QuartzTrigger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cron&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/10 * * * * ?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HelloWorldJob&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;implements&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Job&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JobExecutionContext&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;throws&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JobExecutionException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world, current time: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LocalDateTime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;now&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DateTimeFormatter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ISO_LOCAL_DATE_TIME&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</content><link href="/archives/quartz-plus/"/><published>2025-03-20T17:51:02+08:06</published></entry><entry><id>/archives/rc-initializr/</id><title>rc-initializr</title><updated>2025-05-16T14:33:17.022166+00:00</updated><author><name>wuxiaoyuan</name><email>im.wuxiaoyuan@gmail.com</email><uri>https://tripleyuan.github.io/</uri></author><content>&lt;p&gt;&lt;a href="https://github.com/spring-io/initializr"&gt;Spring Initializr&lt;/a&gt; 是一个基于Web的工具，可快速创建SpringBoot项目。一些流行的IDE，比如Intellij IDEA，已经集成了Spring Initializr，帮助我们快速创建一个SpirngBoot项目。&lt;/p&gt;&lt;p&gt;官方提供的Spring Initializr生成的SpringBoot项目十分简单，如下所示：&lt;/p&gt;&lt;figure style="flex: 36.59090909090909" &gt;&lt;img loading="lazy" width="483" height="660" src="/archives/assets/4e91fdbca57392e493dc5f06a90202a0.png" /&gt;&lt;/figure&gt;&lt;p&gt;我们在日常开发中，经常需要创建各种项目，而这些项目之间，可能存在大量相同，甚至类似的代码，比如Redis配置类、Quartz配置类、一些常用的工具类等等。为了在创建新的项目时，一并生成这些可重复使用的代码，rc-initializr诞生了，它是基于Spring Initializr定制的项目生成器。&lt;/p&gt;&lt;p&gt;下面以Intellij IDEA为例，演示如何使用rc-initializr创建项目：&lt;/p&gt;&lt;p&gt;(1)  打开Intellij IDEA，进入New Project界面&lt;/p&gt;&lt;figure style="flex: 54.15584415584416" &gt;&lt;img loading="lazy" width="834" height="770" src="/archives/assets/b8a626381cbeaf57abbfd04a5f8386d6.png" /&gt;&lt;figcaption&gt;step1.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;修改Service Url为：&lt;a href="http://localhost:8080"&gt;http://localhost:8080&lt;/a&gt; (本地启动的服务地址，根据实际情况填写)&lt;/p&gt;&lt;p&gt;输入项目信息后，点击Next&lt;/p&gt;&lt;p&gt;(2) 选择SpringBoot版本和依赖&lt;/p&gt;&lt;figure style="flex: 54.15584415584416" &gt;&lt;img loading="lazy" width="834" height="770" src="/archives/assets/25abe75add0aa61dfff67ef06b253e66.png" /&gt;&lt;figcaption&gt;step2.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;默认添加的依赖：spring-web, spring-data-redis, jedis, quartz, validation, apache-commons-pool, apache-commons-lang3, commons-collections, lombok, spring-data-jpa.&lt;/p&gt;&lt;p&gt;(3) 点击Finish，项目创建成功，目录结构如下&lt;/p&gt;&lt;figure style="flex: 54.15584415584416" &gt;&lt;img loading="lazy" width="834" height="770" src="/archives/assets/25abe75add0aa61dfff67ef06b253e66.png" /&gt;&lt;figcaption&gt;step3.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;至此，项目创建完成，包含了我们常用的配置代码、工具类和一些依赖等。&lt;/p&gt;</content><link href="/archives/rc-initializr/"/><published>2025-03-20T20:19:16+08:06</published></entry><entry><id>/archives/install-pdftotext-with-anaconda3/</id><title>Install pdftotext with Anaconda3</title><updated>2025-05-16T14:33:17.022129+00:00</updated><author><name>wuxiaoyuan</name><email>im.wuxiaoyuan@gmail.com</email><uri>https://tripleyuan.github.io/</uri></author><content>&lt;h1&gt;解决Anaconda3依赖安装缓慢难题：pdftotext安装过程全记录&lt;/h1&gt;
&lt;h2&gt;背景需求&lt;/h2&gt;
&lt;p&gt;在开发电子书解析工具时，我需要通过Python提取PDF文本内容。&lt;code&gt;pdftotext&lt;/code&gt;作为高效的PDF解析库成为首选，但没想到依赖安装过程如此艰难，竟让我经历了8小时的&amp;quot;渡劫式&amp;quot;安装历程。&lt;/p&gt;&lt;hr /&gt;
&lt;h2&gt;踩坑全记录&lt;/h2&gt;
&lt;h3&gt;第一阶段：pip安装遭遇C++环境缺失&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;pdftotext&lt;span class="w"&gt; &lt;/span&gt;--global-option&lt;span class="o"&gt;=&lt;/span&gt;build_ext...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遭遇经典错误提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Microsoft Visual C++ 14.0 or greater is required.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;应对方案&lt;/strong&gt;：安装 &lt;a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/"&gt;Microsoft C++ Build Tools&lt;/a&gt; ，公司网络较慢，经过两个小时的漫长等待，终于安装成功了。。&lt;/p&gt;&lt;p&gt;安装完 Build Tools 后，新的拦路虎出现了——&lt;code&gt;poppler-cpp&lt;/code&gt;依赖缺失。&lt;/p&gt;&lt;h3&gt;第二阶段：poppler依赖的死亡循环&lt;/h3&gt;
&lt;p&gt;通过MSYS2手动安装poppler后，环境变量配置始终不生效：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;pkg-config&lt;span class="w"&gt; &lt;/span&gt;--cflags&lt;span class="w"&gt; &lt;/span&gt;--libs&lt;span class="w"&gt; &lt;/span&gt;poppler-cpp
Package&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;poppler-cpp&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;not&lt;span class="w"&gt; &lt;/span&gt;found
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时陷入依赖迷宫：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;手动编译poppler耗时且易出错&lt;/li&gt;
&lt;li&gt;Windows环境下的路径配置复杂度陡增&lt;/li&gt;
&lt;li&gt;旧版Anaconda的依赖解析算法存在严重性能问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;第三阶段：Anaconda版本的正确抉择&lt;/h3&gt;
&lt;p&gt;根据大模型建议安装Anaconda3-2020.11版本后，遭遇&lt;strong&gt;依赖解析耗时黑洞&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;1小时等待无进展&lt;/li&gt;
&lt;li&gt;手动安装&lt;code&gt;poppler&lt;/code&gt;后仍报相同错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;破局关键&lt;/strong&gt;：果断更换最新版Anaconda3-2024.10，并配置国内镜像源：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;conda&lt;span class="w"&gt; &lt;/span&gt;config&lt;span class="w"&gt; &lt;/span&gt;--add&lt;span class="w"&gt; &lt;/span&gt;channels&lt;span class="w"&gt; &lt;/span&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main
conda&lt;span class="w"&gt; &lt;/span&gt;config&lt;span class="w"&gt; &lt;/span&gt;--add&lt;span class="w"&gt; &lt;/span&gt;channels&lt;span class="w"&gt; &lt;/span&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free
conda&lt;span class="w"&gt; &lt;/span&gt;config&lt;span class="w"&gt; &lt;/span&gt;--add&lt;span class="w"&gt; &lt;/span&gt;channels&lt;span class="w"&gt; &lt;/span&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;最终胜利时刻&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;conda&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;pdftotext&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;# 国内镜像+新版conda=3分钟完成安装&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;技术要点总结&lt;/h2&gt;
&lt;h3&gt;1. 环境搭建黄金法则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新版工具优先&lt;/strong&gt;：Anaconda2024相较旧版在依赖解析速度上有代际差距&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;镜像源标配化&lt;/strong&gt;：国内镜像速度提升可达10倍（实测下载速度从20KB/s→2MB/s）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++环境预装&lt;/strong&gt;：提前安装VC++14+可避免80%的Python包编译错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 依赖管理技巧&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;graph LR
A[安装报错] --&amp;gt; B{检查错误类型}
B --&amp;gt;|C++相关| C[安装Build Tools]
B --&amp;gt;|依赖缺失| D[conda优先于pip]
D --&amp;gt; E[配置镜像源]
E --&amp;gt; F[新版Anaconda]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3. pdftotext的局限认知&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;纯文本提取：★★★★☆&lt;/li&gt;
&lt;li&gt;公式/表格解析：★☆☆☆（转为纯文本后格式丢失）&lt;/li&gt;
&lt;li&gt;复杂版式处理：建议结合PDFMiner等工具协同工作&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;经验升华&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;大模型使用边界&lt;/strong&gt;：AI助手可提供解决思路，但具体路径验证仍需人工判断&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环境隔离必要性&lt;/strong&gt;：全程在虚拟环境中操作，避免污染系统环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误日志分析法&lt;/strong&gt;：重点观察&lt;code&gt;error&lt;/code&gt;关键词后的第一段有效信息&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;后记：当看到终端终于出现&lt;code&gt;Successfully installed pdftotext-3.0.0&lt;/code&gt;时，窗外已是华灯初上。这场安装战役教会我的不仅是技术解决之道，更是对工具链生态的深刻理解——在Python的世界里，有时候选对工具版本比写代码更重要。&lt;/p&gt;&lt;/blockquote&gt;
</content><link href="/archives/install-pdftotext-with-anaconda3/"/><published>2025-04-23T08:43:15+08:06</published></entry><entry><id>/archives/JCA-essentials/</id><title>JCA Essentials: A Practical Guide to Java Cryptography (Hashing, Signing, Encryption)</title><updated>2025-05-16T14:33:17.022068+00:00</updated><author><name>wuxiaoyuan</name><email>im.wuxiaoyuan@gmail.com</email><uri>https://tripleyuan.github.io/</uri></author><content>&lt;h1&gt;深入浅出 Java 密码学架构（JCA）&lt;/h1&gt;
&lt;h2&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;在当今数字化的世界里，安全性是构建可靠应用不可或缺的一环。对于 Java 平台而言，安全性更是其核心设计理念之一。它涵盖了从语言层面到更高级别的安全通信、身份认证等诸多领域。&lt;/p&gt;&lt;p&gt;而 &lt;strong&gt;Java 密码学架构（JCA）&lt;/strong&gt; 正是 Java 平台安全体系中的一个关键组件。它提供了一套强大而灵活的 API，使得开发者能够轻松地在自己的应用程序中集成各种密码学功能，例如数字签名、消息摘要（哈希）、数据加解密、密钥生成与管理，以及安全随机数生成等。&lt;/p&gt;&lt;p&gt;JCA 的设计理念独具匠心，主要围绕以下三个核心原则构建：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;实现独立性：&lt;/strong&gt; 开发者无需关注底层安全算法的具体实现细节，只需通过标准的 Java API 请求所需的安全服务。具体的实现由不同的 Provider 提供，这使得应用程序可以依赖不同的 Provider，提高了灵活性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现互操作性：&lt;/strong&gt; 不同的 Provider 实现能够协同工作，例如一个 Provider 生成的密钥可以被另一个 Provider 使用，或者一个 Provider 生成的签名可以被另一个 Provider 验证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算法可扩展性：&lt;/strong&gt; JCA 支持集成新的或自定义的安全算法实现，允许开发者根据需求安装和使用第三方 Provider。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将带您深入了解 JCA 的架构和核心概念，并通过常见的功能示例（如加解密、消息摘要、数字签名），演示如何在 Java 应用中实际使用 JCA，帮助您更好地利用这一强大的安全工具。&lt;/p&gt;&lt;h2&gt;2. JCA 架构概述&lt;/h2&gt;
&lt;p&gt;JCA 的核心魅力在于其灵活的架构，它巧妙地将应用程序代码与底层加密算法实现解耦。这种解耦主要通过以下两个关键机制实现：&lt;strong&gt;Provider 架构&lt;/strong&gt; 和 &lt;strong&gt;引擎类/SPI&lt;/strong&gt; 设计。&lt;/p&gt;&lt;h3&gt;Provider 架构：安全能力的提供者&lt;/h3&gt;
&lt;p&gt;正如引言中所述，Provider 是 JCA 架构的基石。它是一个软件包的集合，包含了特定安全服务（如数字签名、加密等）的具体实现。每个 Provider 都是 &lt;code&gt;java.security.Provider&lt;/code&gt; 类的子类，并在其中注册了其提供的各种安全算法和服务的映射关系。&lt;/p&gt;&lt;p&gt;当应用程序需要执行某个密码学操作时，它不是直接调用算法实现，而是向 JCA 框架请求该操作的一个实例。请求时需要指定&lt;strong&gt;算法名称&lt;/strong&gt;（例如：“SHA-256”、“AES”）。应用程序可以选择是否指定一个特定的 Provider 名称来获取实现。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不指定 Provider：&lt;/strong&gt; 如果应用程序只指定算法名称，JCA 框架会按照预设的优先级顺序搜索所有已安装的 Provider，查找第一个支持该算法的 Provider，并返回其实现实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指定 Provider：&lt;/strong&gt; 如果应用程序明确指定了 Provider 的名称，JCA 框架会直接请求该 Provider 提供算法实现。即使有其他优先级更高的 Provider 也支持该算法，框架也会优先使用指定的 Provider。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种机制使得应用程序能够在不修改代码的情况下，灵活地切换或更新底层安全算法的实现。想象一下，当某个算法出现更高效或更安全的实现时，只需安装新的 Provider 并调整其优先级，应用程序就能自动使用新的实现。&lt;/p&gt;&lt;p&gt;当应用程序需要获取某个特定算法的实现时，通常会调用相应引擎类的静态工厂方法 &lt;code&gt;getInstance()&lt;/code&gt;。这个方法是 JCA 框架查找并实例化 Provider 实现的入口点。&lt;/p&gt;&lt;p&gt;例如，要获取一个用于计算 SHA-256 消息摘要的对象，我们可以使用 &lt;code&gt;MessageDigest&lt;/code&gt; 类的 &lt;code&gt;getInstance()&lt;/code&gt; 方法：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 不指定 Provider，让 JCA 框架自动选择&lt;/span&gt;
&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;md1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 指定使用名为 &amp;quot;ProviderC&amp;quot; 的 Provider&lt;/span&gt;
&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;md2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ProviderC&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行代码请求一个“SHA-256”算法的 &lt;code&gt;MessageDigest&lt;/code&gt; 实现，但没有指定由哪个 Provider 提供。此时，JCA 框架会按照已安装 Provider 的优先级顺序进行搜索。如下图（图示 1）所示，假设系统中安装了三个 Provider，ProviderB 是第一个支持 SHA-256 算法的（尽管 ProviderC 也支持），因此框架会返回 ProviderB 提供的实现。&lt;/p&gt;&lt;figure style="flex: 47.7979274611399" &gt;&lt;img loading="lazy" width="369" height="386" src="https://docs.oracle.com/javase/8/docs/technotes/guides/security/overview/images/jssec_dt_011.png" /&gt;&lt;figcaption&gt;diagram showing an application requesting an SHA-256 algorithem without specifying a provider name&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第二行代码则明确指定要使用名为 &amp;quot;ProviderC&amp;quot; 的 Provider 来获取 SHA-256 算法的实现。如下图（图示 2）所示，在这种情况下，JCA 框架会直接请求 ProviderC 提供实现，即使存在优先级更高的 Provider（如 ProviderB）也支持该算法。&lt;/p&gt;&lt;figure style="flex: 53.49740932642487" &gt;&lt;img loading="lazy" width="413" height="386" src="https://docs.oracle.com/javase/8/docs/technotes/guides/security/overview/images/jssec_dt_012.png" /&gt;&lt;figcaption&gt;diagram showing an application requesting an SHA-256 algorithem from a specific provider&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这种灵活的选择机制是 JCA 架构的核心优势之一，它使得应用程序能够适应不同的安全环境和需求。通常情况下，对于通用应用而言，不指定 Provider 是更好的选择，这样可以利用系统当前环境下最优（优先级最高）的实现，例如可能包含了硬件加速或针对特定操作系统优化的 Provider。只有在需要使用特定 Provider（例如出于合规性要求使用经过认证的 Provider）时，才应该明确指定。&lt;/p&gt;&lt;h3&gt;引擎类与 SPI：API 与实现的桥梁&lt;/h3&gt;
&lt;p&gt;JCA 不仅定义了 Provider 如何提供服务，还通过一套精巧的设计，实现了应用程序代码与具体算法的&lt;strong&gt;算法独立性&lt;/strong&gt;。这主要得益于&lt;strong&gt;引擎类（Engine Classes）&lt;/strong&gt;和&lt;strong&gt;服务 Provider 接口（Service Provider Interfaces, SPI）&lt;/strong&gt;的设计。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;引擎类&lt;/strong&gt;是 JCA 提供给应用程序使用的标准 API 接口，它们代表了特定类型的密码学服务，例如：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MessageDigest&lt;/code&gt;: 用于计算数据的消息摘要（哈希）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Signature&lt;/code&gt;: 用于生成或验证数字签名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cipher&lt;/code&gt;: 用于数据的加密和解密。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyPairGenerator&lt;/code&gt;: 用于生成公私钥对。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyGenerator&lt;/code&gt;: 用于生成秘密密钥。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyFactory&lt;/code&gt;: 用于在不同密钥表示形式之间进行转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyStore&lt;/code&gt;: 用于管理密钥和证书的存储库。&lt;/li&gt;
&lt;li&gt;以及其他一些类，如 &lt;code&gt;SecureRandom&lt;/code&gt;, &lt;code&gt;AlgorithmParameters&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些引擎类提供了一组标准的、与具体算法实现无关的方法供应用程序调用。开发者通过这些统一的 API 接口来使用密码学功能，而无需了解底层是哪种算法（例如是 AES 还是 DES 进行加密）或者是由哪个 Provider 提供的实现。&lt;/p&gt;&lt;p&gt;与每个引擎类相对应的是一个抽象的 &lt;strong&gt;服务 Provider 接口（SPI）&lt;/strong&gt; 类。这些 SPI 类定义了 Provider 在实现特定类型的安全服务时必须提供的方法。通常，SPI 类的名称是在其对应的引擎类名称后加上 &lt;code&gt;Spi&lt;/code&gt;，例如 &lt;code&gt;MessageDigestSpi&lt;/code&gt;、&lt;code&gt;SignatureSpi&lt;/code&gt;、&lt;code&gt;CipherSpi&lt;/code&gt; 等。Provider 中提供具体算法实现的类，就是继承自这些 SPI 类并实现了其中的抽象方法。&lt;/p&gt;&lt;p&gt;JCA 框架充当了应用程序引擎类调用和 Provider SPI 实现之间的“桥梁”。当应用程序通过 &lt;code&gt;getInstance()&lt;/code&gt; 方法请求一个引擎类实例时，JCA 框架会根据前面提到的 Provider 选择机制，找到合适的 Provider 及其对应的 SPI 实现类。框架会实例化这个 SPI 实现类，并将其“封装”在一个新的引擎类对象内部。&lt;/p&gt;&lt;p&gt;之后，当应用程序调用引擎类对象上的 API 方法（例如 &lt;code&gt;Cipher&lt;/code&gt; 对象的 &lt;code&gt;init()&lt;/code&gt;、&lt;code&gt;update()&lt;/code&gt;、&lt;code&gt;doFinal()&lt;/code&gt; 方法）时，引擎类会将这些调用转发（或称为“路由”）给其内部封装的 SPI 实现对象中对应的方法（例如 &lt;code&gt;CipherSpi&lt;/code&gt; 实现中的 &lt;code&gt;engineInit()&lt;/code&gt;、&lt;code&gt;engineUpdate()&lt;/code&gt;、&lt;code&gt;engineDoFinal()&lt;/code&gt; 方法）。真正的密码学计算就由 Provider 实现的这些 SPI 方法来完成。&lt;/p&gt;&lt;p&gt;这种模式确保了应用程序代码只与标准的引擎类 API 交互，而底层的算法实现则由 Provider 提供并通过 SPI 接口接入。这完美地体现了 JCA 的算法独立性和实现独立性。&lt;/p&gt;&lt;p&gt;我们可以用一个简化的流程图来表示这个调用过程：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;AES&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ENCRYPT_MODE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;figure style="flex: 30.945558739255013" &gt;&lt;img loading="lazy" width="216" height="349" src="https://docs.oracle.com/javase/8/docs/technotes/guides/security/images/jca/ArchDesignPrincipals.gif" /&gt;&lt;figcaption&gt;Example of How Application Retrieves AES Cipher Intstance&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，应用程序请求 &lt;code&gt;Cipher&lt;/code&gt; 实例（例如 &amp;quot;AES&amp;quot;），JCA 框架找到 Provider 中的 &lt;code&gt;CipherSpi&lt;/code&gt; 实现类（例如 &lt;code&gt;com.foo.AESCipher&lt;/code&gt;），实例化后封装在 &lt;code&gt;Cipher&lt;/code&gt; 对象中返回。应用程序对 &lt;code&gt;Cipher&lt;/code&gt; 对象进行的操作（如 &lt;code&gt;init()&lt;/code&gt;）实际上是调用了封装的 SPI 对象上的对应方法（&lt;code&gt;engineInit()&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;通过 Provider 架构和引擎类/SPI 的协同工作，JCA 构建了一个灵活、可扩展且易于使用的密码学服务框架。&lt;/p&gt;&lt;h2&gt;3. JCA 核心概念与类&lt;/h2&gt;
&lt;p&gt;了解了 JCA 的 Provider 架构和引擎类/SPI 机制后，接下来我们将聚焦于 JCA 中提供各种密码学功能的具体核心类和接口。它们是您在编写安全相关代码时将直接打交道的构建块。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 安全随机数生成：&lt;code&gt;SecureRandom&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在密码学中，随机性至关重要，尤其是在生成密钥、初始化向量 (IV) 等场景。&lt;code&gt;java.security.SecureRandom&lt;/code&gt; 类是一个引擎类，专门用于生成加密强度高、不可预测的随机数。与普通的 &lt;code&gt;java.lang.Random&lt;/code&gt; 不同，&lt;code&gt;SecureRandom&lt;/code&gt; 生成的随机数更难以被攻击者预测，从而增强了安全性。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 通常可以使用无参构造函数 &lt;code&gt;new SecureRandom()&lt;/code&gt; 获取默认的强随机数生成器，或者使用 &lt;code&gt;getInstance()&lt;/code&gt; 方法获取特定算法的实现，甚至可以通过 &lt;code&gt;getInstanceStrong()&lt;/code&gt; 获取由系统属性指定的“最强”实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置种子：&lt;/strong&gt; 可以使用 &lt;code&gt;setSeed()&lt;/code&gt; 方法为生成器设置种子，这有助于初始化生成器的内部状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成随机字节：&lt;/strong&gt; 主要通过 &lt;code&gt;nextBytes(byte[] bytes)&lt;/code&gt; 方法将随机字节填充到指定的字节数组中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 消息摘要：&lt;code&gt;MessageDigest&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;消息摘要（或称哈希、散列）是一种将任意长度的数据映射为固定长度“指纹”的技术。在 JCA 中，&lt;code&gt;java.security.MessageDigest&lt;/code&gt; 类提供了消息摘要的功能。消息摘要的主要特性是微小的数据改动都会导致摘要值发生显著变化，且从摘要值反推出原始数据在计算上是不可行的（单向性）。这使得它非常适合用于验证数据的完整性。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 使用 &lt;code&gt;getInstance(String algorithm)&lt;/code&gt; 方法获取特定算法（如 &amp;quot;SHA-256&amp;quot;、&amp;quot;MD5&amp;quot;）的 &lt;code&gt;MessageDigest&lt;/code&gt; 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理数据：&lt;/strong&gt; 通过 &lt;code&gt;update(byte[] input)&lt;/code&gt; 或 &lt;code&gt;update(byte[] input, int offset, int len)&lt;/code&gt; 方法向摘要对象提供待处理的数据。可以分多次调用 &lt;code&gt;update&lt;/code&gt; 来处理大量数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算摘要：&lt;/strong&gt; 调用 &lt;code&gt;digest()&lt;/code&gt; 方法完成计算并返回最终的摘要字节数组。&lt;code&gt;digest()&lt;/code&gt; 方法调用后，&lt;code&gt;MessageDigest&lt;/code&gt; 对象会自动重置，可以用于计算新的数据的摘要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 数字签名：&lt;code&gt;Signature&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数字签名用于验证数据的来源和完整性。在 JCA 中，&lt;code&gt;java.security.Signature&lt;/code&gt; 类提供了数字签名和验证的功能。签名过程通常使用私钥对数据的哈希值进行加密生成签名，验证过程则使用对应的公钥解密签名，并与待验证数据的哈希值进行比对。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Signature&lt;/code&gt; 对象具有不同的状态：未初始化、签名（SIGN）和验证（VERIFY）。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 使用 &lt;code&gt;getInstance(String algorithm)&lt;/code&gt; 方法获取特定签名算法（如 &amp;quot;SHA256withDSA&amp;quot;、&amp;quot;SHA256withRSA&amp;quot;）的 &lt;code&gt;Signature&lt;/code&gt; 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;签名：&lt;/strong&gt; 使用私钥通过 &lt;code&gt;initSign(PrivateKey privateKey)&lt;/code&gt; 方法初始化对象为签名状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证：&lt;/strong&gt; 使用公钥通过 &lt;code&gt;initVerify(PublicKey publicKey)&lt;/code&gt; 或 &lt;code&gt;initVerify(Certificate certificate)&lt;/code&gt; 方法初始化对象为验证状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理数据：&lt;/strong&gt; 在签名或验证状态下，使用 &lt;code&gt;update(byte[] data)&lt;/code&gt; 方法向对象提供待签名或验证的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行操作：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;签名：&lt;/strong&gt; 调用 &lt;code&gt;sign()&lt;/code&gt; 方法生成数字签名，返回签名字节数组。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证：&lt;/strong&gt; 调用 &lt;code&gt;verify(byte[] signature)&lt;/code&gt; 方法，传入待验证的签名，返回一个布尔值表示签名是否有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 加解密：&lt;code&gt;Cipher&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;加解密是保护数据机密性的手段，在 JCA 中，&lt;code&gt;javax.crypto.Cipher&lt;/code&gt; 类提供了加解密功能。它支持对称加密（使用同一个密钥进行加解密）和非对称加密（使用公私钥对进行加解密），以及块加密和流加密等多种模式。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 使用 &lt;code&gt;getInstance(String transformation)&lt;/code&gt; 方法获取 &lt;code&gt;Cipher&lt;/code&gt; 实例。这里的 &lt;code&gt;transformation&lt;/code&gt; 是一个字符串，通常格式为 &amp;quot;算法名称/模式/填充方式&amp;quot;（例如 &amp;quot;AES/CBC/PKCS5Padding&amp;quot;）或仅算法名称（例如 &amp;quot;AES&amp;quot;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化：&lt;/strong&gt; 使用 &lt;code&gt;init()&lt;/code&gt; 方法初始化 &lt;code&gt;Cipher&lt;/code&gt; 对象，需要指定操作模式（&lt;code&gt;Cipher.ENCRYPT_MODE&lt;/code&gt; 或 &lt;code&gt;Cipher.DECRYPT_MODE&lt;/code&gt;）、密钥，以及可选的算法参数（如初始化向量 IV）和随机源。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;init(int opmode, Key key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init(int opmode, Key key, AlgorithmParameterSpec params)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理数据：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单步操作：&lt;/strong&gt; 对于少量数据，可以直接使用 &lt;code&gt;doFinal(byte[] input)&lt;/code&gt; 或 &lt;code&gt;doFinal(byte[] input, int inputOffset, int inputLen)&lt;/code&gt; 方法进行一步加解密。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多步操作：&lt;/strong&gt; 对于大量数据或流式处理，可以使用 &lt;code&gt;update(byte[] input)&lt;/code&gt; 方法分块处理数据，最后调用 &lt;code&gt;doFinal()&lt;/code&gt; 方法完成最终的加解密和处理剩余数据（包括填充/去填充）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;辅助类：&lt;/strong&gt; JCA 还提供了 &lt;code&gt;CipherInputStream&lt;/code&gt; 和 &lt;code&gt;CipherOutputStream&lt;/code&gt; 用于流式加解密，以及 &lt;code&gt;SealedObject&lt;/code&gt; 用于封装和保护可序列化的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 密钥表示与管理：&lt;code&gt;Key&lt;/code&gt;, &lt;code&gt;KeySpec&lt;/code&gt;, &lt;code&gt;KeyFactory&lt;/code&gt;, &lt;code&gt;KeyGenerator&lt;/code&gt;, &lt;code&gt;KeyPairGenerator&lt;/code&gt;, &lt;code&gt;KeyStore&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;密钥是密码学操作的核心要素，JCA 提供了一系列类和接口来表示、生成和管理密钥。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;密钥接口 (&lt;code&gt;Key&lt;/code&gt;, &lt;code&gt;PublicKey&lt;/code&gt;, &lt;code&gt;PrivateKey&lt;/code&gt;, &lt;code&gt;SecretKey&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.Key&lt;/code&gt; 是所有密钥的不透明表示的顶级接口。它定义了密钥的三个基本属性：算法 (&lt;code&gt;getAlgorithm()&lt;/code&gt;)、编码格式 (&lt;code&gt;getFormat()&lt;/code&gt;) 和编码后的字节 (&lt;code&gt;getEncoded()&lt;/code&gt;)。&lt;code&gt;PublicKey&lt;/code&gt; 和 &lt;code&gt;PrivateKey&lt;/code&gt; 分别表示非对称密钥对中的公钥和私钥，&lt;code&gt;javax.crypto.SecretKey&lt;/code&gt; 表示对称密钥或秘密密钥。这里的“不透明”意味着您通常无法直接访问构成密钥的具体数值，而是将其作为一个整体对象使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥对 (&lt;code&gt;KeyPair&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.KeyPair&lt;/code&gt; 是一个简单的容器类，用于持有配对的公钥 (&lt;code&gt;getPublic()&lt;/code&gt;) 和私钥 (&lt;code&gt;getPrivate()&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥规范 (&lt;code&gt;KeySpec&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.spec.KeySpec&lt;/code&gt; 接口及其实现类提供了密钥材料的“透明”表示。透明表示允许您访问构成密钥的具体数值。例如，&lt;code&gt;DSAPrivateKeySpec&lt;/code&gt; 允许访问 DSA 私钥的各个组成部分（x, p, q, g）。&lt;code&gt;EncodedKeySpec&lt;/code&gt; 的子类（如 &lt;code&gt;PKCS8EncodedKeySpec&lt;/code&gt; 和 &lt;code&gt;X509EncodedKeySpec&lt;/code&gt;）表示密钥的编码格式（如 PKCS#8 用于私钥，X.509 用于公钥）。&lt;code&gt;javax.crypto.spec.SecretKeySpec&lt;/code&gt; 是一个常用的类，可以用字节数组和算法名称直接构造一个 &lt;code&gt;SecretKey&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥工厂 (&lt;code&gt;KeyFactory&lt;/code&gt;, &lt;code&gt;SecretKeyFactory&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.KeyFactory&lt;/code&gt;（用于公钥/私钥）和 &lt;code&gt;javax.crypto.SecretKeyFactory&lt;/code&gt;（用于秘密密钥）是引擎类，用于在密钥的&lt;strong&gt;不透明表示 (&lt;code&gt;Key&lt;/code&gt;)&lt;/strong&gt; 和&lt;strong&gt;透明表示 (&lt;code&gt;KeySpec&lt;/code&gt;)&lt;/strong&gt; 之间进行转换。它们可以从 &lt;code&gt;KeySpec&lt;/code&gt; 生成 &lt;code&gt;Key&lt;/code&gt; 对象（&lt;code&gt;generatePublic/Private/Secret(KeySpec keySpec)&lt;/code&gt;），也可以从 &lt;code&gt;Key&lt;/code&gt; 对象获取相应的 &lt;code&gt;KeySpec&lt;/code&gt;（&lt;code&gt;getKeySpec(Key key, Class keySpec)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥生成器 (&lt;code&gt;KeyGenerator&lt;/code&gt;, &lt;code&gt;KeyPairGenerator&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;javax.crypto.KeyGenerator&lt;/code&gt;（用于秘密密钥）和 &lt;code&gt;java.security.KeyPairGenerator&lt;/code&gt;（用于密钥对）是引擎类，用于&lt;strong&gt;生成全新的密钥&lt;/strong&gt;。您可以指定密钥大小和随机源来初始化生成器，然后调用 &lt;code&gt;generateKey()&lt;/code&gt; 或 &lt;code&gt;generateKeyPair()&lt;/code&gt; 生成密钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥库 (&lt;code&gt;KeyStore&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.KeyStore&lt;/code&gt; 是一个重要的引擎类，提供了一个抽象接口来访问和管理密钥和证书的存储库。它可以用于持久化存储私钥、秘密密钥和可信证书。常见的密钥库类型包括 &amp;quot;jks&amp;quot; (Java KeyStore, 专有格式) 和 &amp;quot;pkcs12&amp;quot; (基于 PKCS#12 标准，更通用)。&lt;code&gt;KeyStore&lt;/code&gt; 提供了加载 (&lt;code&gt;load()&lt;/code&gt;)、获取条目 (&lt;code&gt;getEntry()&lt;/code&gt;)、设置条目 (&lt;code&gt;setEntry()&lt;/code&gt;) 和保存 (&lt;code&gt;store()&lt;/code&gt;) 等方法来操作密钥库中的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6. 证书与 CRL：&lt;code&gt;CertificateFactory&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;证书是用于验证公钥所有者身份的数字文档，通常由证书颁发机构 (CA) 签名。证书吊销列表 (CRL) 列出了已被吊销的证书。&lt;code&gt;java.security.cert.CertificateFactory&lt;/code&gt; 是一个引擎类，用于从编码格式（如 X.509）生成证书和 CRL 对象。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 使用 &lt;code&gt;getInstance(String type)&lt;/code&gt; 方法获取特定证书类型（如 &amp;quot;X.509&amp;quot;）的 &lt;code&gt;CertificateFactory&lt;/code&gt; 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成证书/CRL：&lt;/strong&gt; 通过 &lt;code&gt;generateCertificate(InputStream inStream)&lt;/code&gt; 或 &lt;code&gt;generateCertificates(InputStream inStream)&lt;/code&gt; 从输入流中读取数据并生成证书对象或集合。类似地，使用 &lt;code&gt;generateCRL(InputStream inStream)&lt;/code&gt; 或 &lt;code&gt;generateCRLs(InputStream inStream)&lt;/code&gt; 生成 CRL 对象或集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;掌握了这些核心类和接口的功能，您就掌握了使用 JCA 构建安全应用的基石。在接下来的部分，我们将通过具体的代码示例，演示如何利用其中的一些类来实现常见的密码学操作。&lt;/p&gt;&lt;h2&gt;4. 常见 JCA 功能使用示例&lt;/h2&gt;
&lt;p&gt;掌握了 JCA 的架构和核心类之后，是时候通过实际代码来感受它的强大之处了。本节将演示如何在 Java 应用程序中实现最常见的密码学操作。&lt;/p&gt;&lt;h3&gt;消息摘要（Hashing）&lt;/h3&gt;
&lt;p&gt;消息摘要用于验证数据的完整性。它将任意长度的数据转化为固定长度的“指纹”。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心类：&lt;/strong&gt; &lt;code&gt;java.security.MessageDigest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例场景：&lt;/strong&gt; 计算一个字符串的 SHA-256 摘要。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.MessageDigest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.NoSuchAlgorithmException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.nio.charset.StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.Base64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 用于将字节数组转换为Base64字符串，方便显示&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MessageDigestExample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;originalMessage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello, JCA! This is a test message.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;原始消息: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;originalMessage&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 1. 获取MessageDigest实例，指定算法为SHA-256&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 2. 更新数据：将字符串转换为字节数组并提供给摘要对象&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encodedhash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;originalMessage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 3. 将字节数组转换为十六进制字符串或Base64字符串以便显示&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bytesToHex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encodedhash&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;base64String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;encodeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encodedhash&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256 摘要 (Hex): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256 摘要 (Base64): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;base64String&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 验证完整性：如果原始消息稍有改动，摘要值会完全不同&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;changedMessage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello, JCA! This is a test message. (changed)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;changedHash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;changedMessage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;修改后消息的 SHA-256 摘要 (Hex): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bytesToHex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;changedHash&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NoSuchAlgorithmException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;err&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;指定的算法不存在: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 辅助方法：将字节数组转换为十六进制字符串&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;bytesToHex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toHexString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;通过 &lt;code&gt;MessageDigest.getInstance(&amp;quot;SHA-256&amp;quot;)&lt;/code&gt; 获取一个 SHA-256 算法的 &lt;code&gt;MessageDigest&lt;/code&gt; 实例。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;digest.digest()&lt;/code&gt; 方法，将输入数据的字节数组传递给它。这个方法会计算摘要并返回字节数组。注意，&lt;code&gt;digest()&lt;/code&gt; 调用后，&lt;code&gt;MessageDigest&lt;/code&gt; 对象会自动重置，可以用于处理下一段数据。&lt;/li&gt;
&lt;li&gt;我们使用 &lt;code&gt;bytesToHex&lt;/code&gt; 辅助方法和 &lt;code&gt;Base64.getEncoder()&lt;/code&gt; 将字节数组形式的摘要转换为可读的十六进制或 Base64 字符串。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;数字签名（Digital Signature）&lt;/h3&gt;
&lt;p&gt;数字签名用于验证数据的来源和完整性，确保数据在传输过程中未被篡改，并且确实由声称的发送方发出。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心类：&lt;/strong&gt; &lt;code&gt;java.security.KeyPairGenerator&lt;/code&gt;, &lt;code&gt;java.security.Signature&lt;/code&gt;, &lt;code&gt;java.security.PublicKey&lt;/code&gt;, &lt;code&gt;java.security.PrivateKey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例场景：&lt;/strong&gt; 使用 RSA 算法对消息进行签名和验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.nio.charset.StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.Base64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DigitalSignatureExample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;This is the original message to be signed.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;原始消息: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 1. 生成密钥对 (公钥和私钥) ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 适用于非对称加密和数字签名&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;KeyPairGenerator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPairGen&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;KeyPairGenerator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;RSA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;keyPairGen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2048&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 初始化密钥生成器，指定密钥长度&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;KeyPair&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPair&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPairGen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;generateKeyPair&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 生成密钥对&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;PublicKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;publicKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPair&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getPublic&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;PrivateKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;privateKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPair&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getPrivate&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 数字签名过程 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 2. 签名数据 ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;Signature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA256withRSA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 指定签名算法&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initSign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;privateKey&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 用私钥初始化签名对象&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 提供待签名的数据&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;digitalSignature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 生成数字签名&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;生成的数字签名 (Base64): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;encodeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitalSignature&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 数字签名验证过程 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 3. 验证签名 ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;Signature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA256withRSA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 同样使用签名算法&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initVerify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;publicKey&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 用公钥初始化验证对象&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 提供原始消息数据&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verified&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitalSignature&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 验证签名&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;签名验证结果: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;verified&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;成功&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 尝试篡改消息后验证&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 尝试篡改消息后验证 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tamperedMessage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;This is the original message to be signed. (TAMPERED)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initVerify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;publicKey&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 重新初始化验证对象&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tamperedMessage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 提供被篡改的消息&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tamperedVerified&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitalSignature&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;篡改后签名验证结果: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tamperedVerified&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;成功&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NoSuchAlgorithmException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;InvalidKeyException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SignatureException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;err&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;发生错误: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;生成密钥对：&lt;/strong&gt; 使用 &lt;code&gt;KeyPairGenerator.getInstance(&amp;quot;RSA&amp;quot;)&lt;/code&gt; 获取 RSA 密钥对生成器，并指定密钥长度（2048位）。&lt;code&gt;generateKeyPair()&lt;/code&gt; 方法生成包含公钥和私钥的 &lt;code&gt;KeyPair&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;签名：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;Signature.getInstance(&amp;quot;SHA256withRSA&amp;quot;)&lt;/code&gt; 获取签名实例，&amp;quot;SHA256withRSA&amp;quot; 表示使用 SHA-256 算法对数据进行哈希，然后用 RSA 算法进行签名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initSign(privateKey)&lt;/code&gt; 用私钥初始化签名对象，进入签名模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update()&lt;/code&gt; 传入需要签名的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sign()&lt;/code&gt; 生成最终的数字签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;同样通过 &lt;code&gt;Signature.getInstance(&amp;quot;SHA256withRSA&amp;quot;)&lt;/code&gt; 获取签名实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initVerify(publicKey)&lt;/code&gt; 用公钥初始化验证对象，进入验证模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update()&lt;/code&gt; 传入&lt;strong&gt;原始的&lt;/strong&gt;（未篡改的）数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;verify(digitalSignature)&lt;/code&gt; 传入收到的数字签名。如果数据未被篡改且签名有效，将返回 &lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;加解密（Encryption/Decryption）&lt;/h3&gt;
&lt;p&gt;加解密用于保护数据的机密性，防止未授权访问。这里我们以常用的对称加密算法 AES 为例。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心类：&lt;/strong&gt; &lt;code&gt;javax.crypto.KeyGenerator&lt;/code&gt;, &lt;code&gt;javax.crypto.Cipher&lt;/code&gt;, &lt;code&gt;javax.crypto.spec.SecretKeySpec&lt;/code&gt;, &lt;code&gt;javax.crypto.spec.IvParameterSpec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例场景：&lt;/strong&gt; 使用 AES/CBC/PKCS5Padding 模式对字符串进行加解密。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.Cipher&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.KeyGenerator&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.SecretKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.spec.IvParameterSpec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 对于CBC模式，需要初始化向量IV&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.spec.SecretKeySpec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.nio.charset.StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.NoSuchAlgorithmException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.InvalidKeyException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.InvalidAlgorithmParameterException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.NoSuchPaddingException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.BadPaddingException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.IllegalBlockSizeException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.SecureRandom&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 用于生成随机IV&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.Base64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EncryptionDecryptionExample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// AES 加密/解密使用的转换模式&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TRANSFORMATION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;AES/CBC/PKCS5Padding&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ALGORITHM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;AES&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;originalText&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello, JCA! This is a secret message to be encrypted.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;原始文本: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;originalText&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 1. 生成密钥和初始化向量 (IV) ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 对于对称加密，我们需要一个秘密密钥&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;KeyGenerator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyGen&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;KeyGenerator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ALGORITHM&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;keyGen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// AES支持128, 192, 256位密钥&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;SecretKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secretKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyGen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;generateKey&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 对于CBC模式，需要一个随机的初始化向量 (IV)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;SecureRandom&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secureRandom&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// AES块大小为16字节&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;secureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;nextBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;IvParameterSpec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ivSpec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IvParameterSpec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 数据加密过程 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 2. 加密数据 ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TRANSFORMATION&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ENCRYPT_MODE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secretKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ivSpec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 初始化为加密模式，传入密钥和IV&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encryptedBytes&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;doFinal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;originalText&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encryptedTextBase64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;encodeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encryptedBytes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ivBase64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;encodeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// IV也需要传输给解密方&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;加密后的文本 (Base64): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encryptedTextBase64&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;使用的 IV (Base64): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ivBase64&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 数据解密过程 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 3. 解密数据 ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 解密时需要相同的密钥和IV&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;retrievedIv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDecoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ivBase64&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 从传输中获取IV&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;IvParameterSpec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;retrievedIvSpec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IvParameterSpec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;retrievedIv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;DECRYPT_MODE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secretKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;retrievedIvSpec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 初始化为解密模式，传入密钥和IV&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decryptedBytes&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;doFinal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDecoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encryptedTextBase64&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decryptedText&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decryptedBytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;解密后的文本: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decryptedText&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NoSuchAlgorithmException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NoSuchPaddingException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;InvalidKeyException&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;InvalidAlgorithmParameterException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IllegalBlockSizeException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BadPaddingException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;err&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;发生错误: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;生成密钥和 IV：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KeyGenerator.getInstance(&amp;quot;AES&amp;quot;)&lt;/code&gt; 获取 AES 密钥生成器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keyGen.init(256)&lt;/code&gt; 初始化生成器，指定密钥长度为 256 位（AES 支持 128, 192, 256）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;generateKey()&lt;/code&gt; 生成 &lt;code&gt;SecretKey&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对于 CBC 模式（或任何块模式），还需要一个随机的&lt;strong&gt;初始化向量 (IV)&lt;/strong&gt;。&lt;code&gt;SecureRandom&lt;/code&gt; 用于生成加密安全的随机 IV，其长度通常与算法的块大小（AES 为 16 字节）相同。&lt;code&gt;IvParameterSpec&lt;/code&gt; 用于封装 IV。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加密：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Cipher.getInstance(&amp;quot;AES/CBC/PKCS5Padding&amp;quot;)&lt;/code&gt; 获取 &lt;code&gt;Cipher&lt;/code&gt; 实例。这里的 &lt;code&gt;&amp;quot;AES/CBC/PKCS5Padding&amp;quot;&lt;/code&gt; 指定了算法（AES）、操作模式（CBC，密文分组链接模式）和填充方式（PKCS5Padding）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec)&lt;/code&gt; 将 &lt;code&gt;Cipher&lt;/code&gt; 初始化为加密模式，传入之前生成的 &lt;code&gt;SecretKey&lt;/code&gt; 和 &lt;code&gt;IvParameterSpec&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cipher.doFinal()&lt;/code&gt; 执行最终的加密操作，返回加密后的字节数组。我们将其转换为 Base64 字符串以便于显示和传输。&lt;strong&gt;请注意，在实际应用中，IV 也必须安全地与密文一起传输给接收方。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解密：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;解密时，需要使用与加密时&lt;strong&gt;相同的密钥&lt;/strong&gt;和&lt;strong&gt;相同的 IV&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cipher.init(Cipher.DECRYPT_MODE, secretKey, retrievedIvSpec)&lt;/code&gt; 将 &lt;code&gt;Cipher&lt;/code&gt; 初始化为解密模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cipher.doFinal()&lt;/code&gt; 执行解密操作，返回原始数据的字节数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好的，我们来完成博客的“总结”部分。这部分将回顾 JCA 的重要性，并对全文进行概括。&lt;/p&gt;&lt;h2&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;通过本文的介绍，相信您已经对 Java 密码学架构（JCA）有了更深入的理解。我们从 JCA 的核心设计理念——&lt;strong&gt;实现独立性、实现互操作性&lt;/strong&gt;和&lt;strong&gt;算法可扩展性&lt;/strong&gt;入手，详细探讨了其&lt;strong&gt;Provider 架构&lt;/strong&gt;以及&lt;strong&gt;引擎类与 SPI&lt;/strong&gt; 的工作机制，它们共同构成了 JCA 强大而灵活的基础。&lt;/p&gt;&lt;p&gt;我们还详细介绍了 JCA 中的一系列核心类和接口，它们是您在编写安全相关代码时的重要工具，包括用于生成安全随机数的 &lt;code&gt;SecureRandom&lt;/code&gt;，验证数据完整性的 &lt;code&gt;MessageDigest&lt;/code&gt;，实现身份认证和防篡改的 &lt;code&gt;Signature&lt;/code&gt;，以及保障数据机密性的 &lt;code&gt;Cipher&lt;/code&gt;。最后，通过实际的 Java 代码示例，我们演示了如何利用这些类来完成消息摘要、数字签名和数据加解密这些常见的密码学操作。&lt;/p&gt;&lt;p&gt;JCA 的核心价值在于它提供了一个标准化的、可插拔的框架，使得开发者能够轻松地在应用程序中集成多样化的密码学功能，而无需陷入底层算法实现的复杂细节。这意味着您可以灵活地选择不同的 Provider，利用最新的算法或硬件加速，同时保持应用程序代码的高度可移植性。&lt;/p&gt;&lt;p&gt;然而，密码学是一个复杂且不断发展的领域。虽然 JCA 极大地简化了密码学功能的使用，但在实际的生产环境中，仍然需要对所选算法的特性、密钥管理策略、数据传输安全等有深入的理解，并遵循最新的安全最佳实践。&lt;/p&gt;</content><link href="/archives/JCA-essentials/"/><published>2025-05-16T22:08:57+08:06</published></entry></feed>