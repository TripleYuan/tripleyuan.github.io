<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Yuan's Blog</title><link>/</link><description>Hello, World!</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>/android-chrome-512x512.png</url><title>Yuan's Blog</title><link>/</link></image><language>english</language><lastBuildDate>Thu, 05 Jun 2025 21:53:24 +0806</lastBuildDate><pubDate>Thu, 05 Jun 2025 21:53:24 +0806</pubDate><item><title>quartz-plus</title><link>/archives/quartz-plus/</link><description>&lt;p&gt;在工作中，我经常会使用到 Quartz，一个开源的分布式任务调度框架。然而，尽管 Quartz 提供了强大的功能，我在使用过程中却遇到了一些痛点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Quartz 不支持注解的方式定义Job，这导致我们只能通过硬编码的方式创建&lt;code&gt;Job&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;，并手动注册到 Quartz scheduler 中。&lt;/li&gt;
&lt;li&gt;Quartz 未提供任务调度管理界面。在实际工作中，我常常需要手动触发某个Job的执行，然而由于缺少管理页面，我们只能通过修改数据库中 trigger 的执行时间来间接触发 job 的执行，这显然不是一个高效的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这些问题，提高开发效率，我基于 Spring 对 Quartz 进行了扩展，开发了一个名为 Quartz Plus 的工具库：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;支持注解的方式快速定义&lt;code&gt;Job&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;：使用 @QuartzJob 和 @QuartzTrigger 注解，我们可以快速地定义&lt;code&gt;Job&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;，并且它们会自动注册到&lt;code&gt;Quartz Scheduler&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;实现了一个带有管理界面的 Quartz 任务调度中心：该任务调度中心提供了完整的管理界面，包括 job 管理、Quartz 实例管理、用户管理等功能，使我们能够更方便地管理和监控任务调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目源码地址：&lt;a href="https://github.com/TripleYuan/quartz-plus.git"&gt;https://github.com/TripleYuan/quartz-plus.git&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;快速上手&lt;/h2&gt;
&lt;h3&gt;部署Quartz任务调度系统&lt;/h3&gt;
&lt;p&gt;调度系统分为前端和后端两个项目，可以分开部署 &lt;strong&gt;quartz-plus-scheduler-center&lt;/strong&gt;（调度服务） 和 &lt;strong&gt;quartz-plus-web-console&lt;/strong&gt;（前端应用），也可将前端代码打包后的静态资源文件集成到 &lt;code&gt;quartz-plus-scheduler-center&lt;/code&gt; 中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;quartz-plus-scheduler-center&lt;/code&gt; 默认使用的是H2数据库，生产环境建议使用外部数据库，如 MySQL、PostgreSQL 等。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;系统内置了两个登录用户：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;用户1：用户名为 admin，密码为 123456，拥有管理员权限。&lt;/p&gt;&lt;p&gt;用户2：用户名为 quartz，密码为 123456，仅具有普通用户权限。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3&gt;SpringBoot应用接入&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;引入最新版本&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;redcoder&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;quartz-plus-core&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${quartzplus.latest.version}&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol start="2"&gt;
&lt;li&gt;在启用类上添加注解 &lt;code&gt;@QuartzJobScan&lt;/code&gt;，并指定 job 类所在的包路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class="nd"&gt;@QuartzJobScan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;redcoder.quartzplus.demo.job&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;QuartzPlusDemoApplication&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;SpringApplication&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QuartzPlusDemoApplication&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol start="3"&gt;
&lt;li&gt;添加配置，指定注册中心服务地址&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;quartz-job-scheduler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;registry&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;# 调度服务注册地址（替换成你的IP和端口）&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;register-url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;http://localhost:32007/api/quartz-job-scheduler/instance/register&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;# 调度服务取消注册地址（替换成你的IP和端口）&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;unregister-url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;http://localhost:32007/api/quartz-job-scheduler/instance/unregister&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;注解式定义Job和Trigger&lt;/h3&gt;
&lt;p&gt;使用 &lt;strong&gt;@QuartzJob&lt;/strong&gt; 和 &lt;strong&gt;@QuartzTrigger&lt;/strong&gt; 注解快速定义 &lt;code&gt;Job&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@QuartzJob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;打印 hello world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@QuartzTrigger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cron&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/10 * * * * ?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HelloWorldJob&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;implements&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Job&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JobExecutionContext&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;throws&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;JobExecutionException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world, current time: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LocalDateTime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;now&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DateTimeFormatter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ISO_LOCAL_DATE_TIME&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><author>im.wuxiaoyuan@gmail.com (wuxiaoyuan)</author><guid isPermaLink="true">/archives/quartz-plus/</guid><pubDate>Thu, 20 Mar 2025 17:51:02 +0806</pubDate></item><item><title>rc-initializr</title><link>/archives/rc-initializr/</link><description>&lt;p&gt;&lt;a href="https://github.com/spring-io/initializr"&gt;Spring Initializr&lt;/a&gt; 是一个基于Web的工具，可快速创建SpringBoot项目。一些流行的IDE，比如Intellij IDEA，已经集成了Spring Initializr，帮助我们快速创建一个SpirngBoot项目。&lt;/p&gt;&lt;p&gt;官方提供的Spring Initializr生成的SpringBoot项目十分简单，如下所示：&lt;/p&gt;&lt;figure style="flex: 36.59090909090909" &gt;&lt;img loading="lazy" width="483" height="660" src="/archives/assets/4e91fdbca57392e493dc5f06a90202a0.png" /&gt;&lt;/figure&gt;&lt;p&gt;我们在日常开发中，经常需要创建各种项目，而这些项目之间，可能存在大量相同，甚至类似的代码，比如Redis配置类、Quartz配置类、一些常用的工具类等等。为了在创建新的项目时，一并生成这些可重复使用的代码，rc-initializr诞生了，它是基于Spring Initializr定制的项目生成器。&lt;/p&gt;&lt;p&gt;下面以Intellij IDEA为例，演示如何使用rc-initializr创建项目：&lt;/p&gt;&lt;p&gt;(1)  打开Intellij IDEA，进入New Project界面&lt;/p&gt;&lt;figure style="flex: 54.15584415584416" &gt;&lt;img loading="lazy" width="834" height="770" src="/archives/assets/b8a626381cbeaf57abbfd04a5f8386d6.png" /&gt;&lt;figcaption&gt;step1.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;修改Service Url为：&lt;a href="http://localhost:8080"&gt;http://localhost:8080&lt;/a&gt; (本地启动的服务地址，根据实际情况填写)&lt;/p&gt;&lt;p&gt;输入项目信息后，点击Next&lt;/p&gt;&lt;p&gt;(2) 选择SpringBoot版本和依赖&lt;/p&gt;&lt;figure style="flex: 54.15584415584416" &gt;&lt;img loading="lazy" width="834" height="770" src="/archives/assets/25abe75add0aa61dfff67ef06b253e66.png" /&gt;&lt;figcaption&gt;step2.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;默认添加的依赖：spring-web, spring-data-redis, jedis, quartz, validation, apache-commons-pool, apache-commons-lang3, commons-collections, lombok, spring-data-jpa.&lt;/p&gt;&lt;p&gt;(3) 点击Finish，项目创建成功，目录结构如下&lt;/p&gt;&lt;figure style="flex: 54.15584415584416" &gt;&lt;img loading="lazy" width="834" height="770" src="/archives/assets/25abe75add0aa61dfff67ef06b253e66.png" /&gt;&lt;figcaption&gt;step3.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;至此，项目创建完成，包含了我们常用的配置代码、工具类和一些依赖等。&lt;/p&gt;</description><author>im.wuxiaoyuan@gmail.com (wuxiaoyuan)</author><guid isPermaLink="true">/archives/rc-initializr/</guid><pubDate>Thu, 20 Mar 2025 20:19:16 +0806</pubDate></item><item><title>Install pdftotext with Anaconda3</title><link>/archives/install-pdftotext-with-anaconda3/</link><description>&lt;h1&gt;解决Anaconda3依赖安装缓慢难题：pdftotext安装过程全记录&lt;/h1&gt;
&lt;h2&gt;背景需求&lt;/h2&gt;
&lt;p&gt;在开发电子书解析工具时，我需要通过Python提取PDF文本内容。&lt;code&gt;pdftotext&lt;/code&gt;作为高效的PDF解析库成为首选，但没想到依赖安装过程如此艰难，竟让我经历了8小时的&amp;quot;渡劫式&amp;quot;安装历程。&lt;/p&gt;&lt;hr /&gt;
&lt;h2&gt;踩坑全记录&lt;/h2&gt;
&lt;h3&gt;第一阶段：pip安装遭遇C++环境缺失&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;pdftotext&lt;span class="w"&gt; &lt;/span&gt;--global-option&lt;span class="o"&gt;=&lt;/span&gt;build_ext...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遭遇经典错误提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Microsoft Visual C++ 14.0 or greater is required.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;应对方案&lt;/strong&gt;：安装 &lt;a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/"&gt;Microsoft C++ Build Tools&lt;/a&gt; ，公司网络较慢，经过两个小时的漫长等待，终于安装成功了。。&lt;/p&gt;&lt;p&gt;安装完 Build Tools 后，新的拦路虎出现了——&lt;code&gt;poppler-cpp&lt;/code&gt;依赖缺失。&lt;/p&gt;&lt;h3&gt;第二阶段：poppler依赖的死亡循环&lt;/h3&gt;
&lt;p&gt;通过MSYS2手动安装poppler后，环境变量配置始终不生效：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;pkg-config&lt;span class="w"&gt; &lt;/span&gt;--cflags&lt;span class="w"&gt; &lt;/span&gt;--libs&lt;span class="w"&gt; &lt;/span&gt;poppler-cpp
Package&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;poppler-cpp&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;not&lt;span class="w"&gt; &lt;/span&gt;found
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时陷入依赖迷宫：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;手动编译poppler耗时且易出错&lt;/li&gt;
&lt;li&gt;Windows环境下的路径配置复杂度陡增&lt;/li&gt;
&lt;li&gt;旧版Anaconda的依赖解析算法存在严重性能问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;第三阶段：Anaconda版本的正确抉择&lt;/h3&gt;
&lt;p&gt;根据大模型建议安装Anaconda3-2020.11版本后，遭遇&lt;strong&gt;依赖解析耗时黑洞&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;1小时等待无进展&lt;/li&gt;
&lt;li&gt;手动安装&lt;code&gt;poppler&lt;/code&gt;后仍报相同错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;破局关键&lt;/strong&gt;：果断更换最新版Anaconda3-2024.10，并配置国内镜像源：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;conda&lt;span class="w"&gt; &lt;/span&gt;config&lt;span class="w"&gt; &lt;/span&gt;--add&lt;span class="w"&gt; &lt;/span&gt;channels&lt;span class="w"&gt; &lt;/span&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main
conda&lt;span class="w"&gt; &lt;/span&gt;config&lt;span class="w"&gt; &lt;/span&gt;--add&lt;span class="w"&gt; &lt;/span&gt;channels&lt;span class="w"&gt; &lt;/span&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free
conda&lt;span class="w"&gt; &lt;/span&gt;config&lt;span class="w"&gt; &lt;/span&gt;--add&lt;span class="w"&gt; &lt;/span&gt;channels&lt;span class="w"&gt; &lt;/span&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;最终胜利时刻&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;conda&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;pdftotext&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;# 国内镜像+新版conda=3分钟完成安装&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;技术要点总结&lt;/h2&gt;
&lt;h3&gt;1. 环境搭建黄金法则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新版工具优先&lt;/strong&gt;：Anaconda2024相较旧版在依赖解析速度上有代际差距&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;镜像源标配化&lt;/strong&gt;：国内镜像速度提升可达10倍（实测下载速度从20KB/s→2MB/s）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++环境预装&lt;/strong&gt;：提前安装VC++14+可避免80%的Python包编译错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 依赖管理技巧&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;graph LR
A[安装报错] --&amp;gt; B{检查错误类型}
B --&amp;gt;|C++相关| C[安装Build Tools]
B --&amp;gt;|依赖缺失| D[conda优先于pip]
D --&amp;gt; E[配置镜像源]
E --&amp;gt; F[新版Anaconda]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3. pdftotext的局限认知&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;纯文本提取：★★★★☆&lt;/li&gt;
&lt;li&gt;公式/表格解析：★☆☆☆（转为纯文本后格式丢失）&lt;/li&gt;
&lt;li&gt;复杂版式处理：建议结合PDFMiner等工具协同工作&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;经验升华&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;大模型使用边界&lt;/strong&gt;：AI助手可提供解决思路，但具体路径验证仍需人工判断&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环境隔离必要性&lt;/strong&gt;：全程在虚拟环境中操作，避免污染系统环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误日志分析法&lt;/strong&gt;：重点观察&lt;code&gt;error&lt;/code&gt;关键词后的第一段有效信息&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;后记：当看到终端终于出现&lt;code&gt;Successfully installed pdftotext-3.0.0&lt;/code&gt;时，窗外已是华灯初上。这场安装战役教会我的不仅是技术解决之道，更是对工具链生态的深刻理解——在Python的世界里，有时候选对工具版本比写代码更重要。&lt;/p&gt;&lt;/blockquote&gt;
</description><author>im.wuxiaoyuan@gmail.com (wuxiaoyuan)</author><guid isPermaLink="true">/archives/install-pdftotext-with-anaconda3/</guid><pubDate>Wed, 23 Apr 2025 08:43:15 +0806</pubDate></item><item><title>JCA Essentials: A Practical Guide to Java Cryptography (Hashing, Signing, Encryption)</title><link>/archives/JCA-essentials/</link><description>&lt;h1&gt;深入浅出 Java 密码学架构（JCA）&lt;/h1&gt;
&lt;h2&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;在当今数字化的世界里，安全性是构建可靠应用不可或缺的一环。对于 Java 平台而言，安全性更是其核心设计理念之一。它涵盖了从语言层面到更高级别的安全通信、身份认证等诸多领域。&lt;/p&gt;&lt;p&gt;而 &lt;strong&gt;Java 密码学架构（JCA）&lt;/strong&gt; 正是 Java 平台安全体系中的一个关键组件。它提供了一套强大而灵活的 API，使得开发者能够轻松地在自己的应用程序中集成各种密码学功能，例如数字签名、消息摘要（哈希）、数据加解密、密钥生成与管理，以及安全随机数生成等。&lt;/p&gt;&lt;p&gt;JCA 的设计理念独具匠心，主要围绕以下三个核心原则构建：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;实现独立性：&lt;/strong&gt; 开发者无需关注底层安全算法的具体实现细节，只需通过标准的 Java API 请求所需的安全服务。具体的实现由不同的 Provider 提供，这使得应用程序可以依赖不同的 Provider，提高了灵活性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现互操作性：&lt;/strong&gt; 不同的 Provider 实现能够协同工作，例如一个 Provider 生成的密钥可以被另一个 Provider 使用，或者一个 Provider 生成的签名可以被另一个 Provider 验证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算法可扩展性：&lt;/strong&gt; JCA 支持集成新的或自定义的安全算法实现，允许开发者根据需求安装和使用第三方 Provider。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将带您深入了解 JCA 的架构和核心概念，并通过常见的功能示例（如加解密、消息摘要、数字签名），演示如何在 Java 应用中实际使用 JCA，帮助您更好地利用这一强大的安全工具。&lt;/p&gt;&lt;h2&gt;2. JCA 架构概述&lt;/h2&gt;
&lt;p&gt;JCA 的核心魅力在于其灵活的架构，它巧妙地将应用程序代码与底层加密算法实现解耦。这种解耦主要通过以下两个关键机制实现：&lt;strong&gt;Provider 架构&lt;/strong&gt; 和 &lt;strong&gt;引擎类/SPI&lt;/strong&gt; 设计。&lt;/p&gt;&lt;h3&gt;Provider 架构：安全能力的提供者&lt;/h3&gt;
&lt;p&gt;正如引言中所述，Provider 是 JCA 架构的基石。它是一个软件包的集合，包含了特定安全服务（如数字签名、加密等）的具体实现。每个 Provider 都是 &lt;code&gt;java.security.Provider&lt;/code&gt; 类的子类，并在其中注册了其提供的各种安全算法和服务的映射关系。&lt;/p&gt;&lt;p&gt;当应用程序需要执行某个密码学操作时，它不是直接调用算法实现，而是向 JCA 框架请求该操作的一个实例。请求时需要指定&lt;strong&gt;算法名称&lt;/strong&gt;（例如：“SHA-256”、“AES”）。应用程序可以选择是否指定一个特定的 Provider 名称来获取实现。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不指定 Provider：&lt;/strong&gt; 如果应用程序只指定算法名称，JCA 框架会按照预设的优先级顺序搜索所有已安装的 Provider，查找第一个支持该算法的 Provider，并返回其实现实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指定 Provider：&lt;/strong&gt; 如果应用程序明确指定了 Provider 的名称，JCA 框架会直接请求该 Provider 提供算法实现。即使有其他优先级更高的 Provider 也支持该算法，框架也会优先使用指定的 Provider。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种机制使得应用程序能够在不修改代码的情况下，灵活地切换或更新底层安全算法的实现。想象一下，当某个算法出现更高效或更安全的实现时，只需安装新的 Provider 并调整其优先级，应用程序就能自动使用新的实现。&lt;/p&gt;&lt;p&gt;当应用程序需要获取某个特定算法的实现时，通常会调用相应引擎类的静态工厂方法 &lt;code&gt;getInstance()&lt;/code&gt;。这个方法是 JCA 框架查找并实例化 Provider 实现的入口点。&lt;/p&gt;&lt;p&gt;例如，要获取一个用于计算 SHA-256 消息摘要的对象，我们可以使用 &lt;code&gt;MessageDigest&lt;/code&gt; 类的 &lt;code&gt;getInstance()&lt;/code&gt; 方法：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 不指定 Provider，让 JCA 框架自动选择&lt;/span&gt;
&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;md1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 指定使用名为 &amp;quot;ProviderC&amp;quot; 的 Provider&lt;/span&gt;
&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;md2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ProviderC&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行代码请求一个“SHA-256”算法的 &lt;code&gt;MessageDigest&lt;/code&gt; 实现，但没有指定由哪个 Provider 提供。此时，JCA 框架会按照已安装 Provider 的优先级顺序进行搜索。如下图（图示 1）所示，假设系统中安装了三个 Provider，ProviderB 是第一个支持 SHA-256 算法的（尽管 ProviderC 也支持），因此框架会返回 ProviderB 提供的实现。&lt;/p&gt;&lt;figure style="flex: 47.7979274611399" &gt;&lt;img loading="lazy" width="369" height="386" src="https://docs.oracle.com/javase/8/docs/technotes/guides/security/overview/images/jssec_dt_011.png" /&gt;&lt;figcaption&gt;diagram showing an application requesting an SHA-256 algorithem without specifying a provider name&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第二行代码则明确指定要使用名为 &amp;quot;ProviderC&amp;quot; 的 Provider 来获取 SHA-256 算法的实现。如下图（图示 2）所示，在这种情况下，JCA 框架会直接请求 ProviderC 提供实现，即使存在优先级更高的 Provider（如 ProviderB）也支持该算法。&lt;/p&gt;&lt;figure style="flex: 53.49740932642487" &gt;&lt;img loading="lazy" width="413" height="386" src="https://docs.oracle.com/javase/8/docs/technotes/guides/security/overview/images/jssec_dt_012.png" /&gt;&lt;figcaption&gt;diagram showing an application requesting an SHA-256 algorithem from a specific provider&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这种灵活的选择机制是 JCA 架构的核心优势之一，它使得应用程序能够适应不同的安全环境和需求。通常情况下，对于通用应用而言，不指定 Provider 是更好的选择，这样可以利用系统当前环境下最优（优先级最高）的实现，例如可能包含了硬件加速或针对特定操作系统优化的 Provider。只有在需要使用特定 Provider（例如出于合规性要求使用经过认证的 Provider）时，才应该明确指定。&lt;/p&gt;&lt;h3&gt;引擎类与 SPI：API 与实现的桥梁&lt;/h3&gt;
&lt;p&gt;JCA 不仅定义了 Provider 如何提供服务，还通过一套精巧的设计，实现了应用程序代码与具体算法的&lt;strong&gt;算法独立性&lt;/strong&gt;。这主要得益于&lt;strong&gt;引擎类（Engine Classes）&lt;/strong&gt;和&lt;strong&gt;服务 Provider 接口（Service Provider Interfaces, SPI）&lt;/strong&gt;的设计。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;引擎类&lt;/strong&gt;是 JCA 提供给应用程序使用的标准 API 接口，它们代表了特定类型的密码学服务，例如：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MessageDigest&lt;/code&gt;: 用于计算数据的消息摘要（哈希）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Signature&lt;/code&gt;: 用于生成或验证数字签名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cipher&lt;/code&gt;: 用于数据的加密和解密。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyPairGenerator&lt;/code&gt;: 用于生成公私钥对。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyGenerator&lt;/code&gt;: 用于生成秘密密钥。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyFactory&lt;/code&gt;: 用于在不同密钥表示形式之间进行转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyStore&lt;/code&gt;: 用于管理密钥和证书的存储库。&lt;/li&gt;
&lt;li&gt;以及其他一些类，如 &lt;code&gt;SecureRandom&lt;/code&gt;, &lt;code&gt;AlgorithmParameters&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些引擎类提供了一组标准的、与具体算法实现无关的方法供应用程序调用。开发者通过这些统一的 API 接口来使用密码学功能，而无需了解底层是哪种算法（例如是 AES 还是 DES 进行加密）或者是由哪个 Provider 提供的实现。&lt;/p&gt;&lt;p&gt;与每个引擎类相对应的是一个抽象的 &lt;strong&gt;服务 Provider 接口（SPI）&lt;/strong&gt; 类。这些 SPI 类定义了 Provider 在实现特定类型的安全服务时必须提供的方法。通常，SPI 类的名称是在其对应的引擎类名称后加上 &lt;code&gt;Spi&lt;/code&gt;，例如 &lt;code&gt;MessageDigestSpi&lt;/code&gt;、&lt;code&gt;SignatureSpi&lt;/code&gt;、&lt;code&gt;CipherSpi&lt;/code&gt; 等。Provider 中提供具体算法实现的类，就是继承自这些 SPI 类并实现了其中的抽象方法。&lt;/p&gt;&lt;p&gt;JCA 框架充当了应用程序引擎类调用和 Provider SPI 实现之间的“桥梁”。当应用程序通过 &lt;code&gt;getInstance()&lt;/code&gt; 方法请求一个引擎类实例时，JCA 框架会根据前面提到的 Provider 选择机制，找到合适的 Provider 及其对应的 SPI 实现类。框架会实例化这个 SPI 实现类，并将其“封装”在一个新的引擎类对象内部。&lt;/p&gt;&lt;p&gt;之后，当应用程序调用引擎类对象上的 API 方法（例如 &lt;code&gt;Cipher&lt;/code&gt; 对象的 &lt;code&gt;init()&lt;/code&gt;、&lt;code&gt;update()&lt;/code&gt;、&lt;code&gt;doFinal()&lt;/code&gt; 方法）时，引擎类会将这些调用转发（或称为“路由”）给其内部封装的 SPI 实现对象中对应的方法（例如 &lt;code&gt;CipherSpi&lt;/code&gt; 实现中的 &lt;code&gt;engineInit()&lt;/code&gt;、&lt;code&gt;engineUpdate()&lt;/code&gt;、&lt;code&gt;engineDoFinal()&lt;/code&gt; 方法）。真正的密码学计算就由 Provider 实现的这些 SPI 方法来完成。&lt;/p&gt;&lt;p&gt;这种模式确保了应用程序代码只与标准的引擎类 API 交互，而底层的算法实现则由 Provider 提供并通过 SPI 接口接入。这完美地体现了 JCA 的算法独立性和实现独立性。&lt;/p&gt;&lt;p&gt;我们可以用一个简化的流程图来表示这个调用过程：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;AES&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ENCRYPT_MODE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;figure style="flex: 30.945558739255013" &gt;&lt;img loading="lazy" width="216" height="349" src="https://docs.oracle.com/javase/8/docs/technotes/guides/security/images/jca/ArchDesignPrincipals.gif" /&gt;&lt;figcaption&gt;Example of How Application Retrieves AES Cipher Intstance&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，应用程序请求 &lt;code&gt;Cipher&lt;/code&gt; 实例（例如 &amp;quot;AES&amp;quot;），JCA 框架找到 Provider 中的 &lt;code&gt;CipherSpi&lt;/code&gt; 实现类（例如 &lt;code&gt;com.foo.AESCipher&lt;/code&gt;），实例化后封装在 &lt;code&gt;Cipher&lt;/code&gt; 对象中返回。应用程序对 &lt;code&gt;Cipher&lt;/code&gt; 对象进行的操作（如 &lt;code&gt;init()&lt;/code&gt;）实际上是调用了封装的 SPI 对象上的对应方法（&lt;code&gt;engineInit()&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;通过 Provider 架构和引擎类/SPI 的协同工作，JCA 构建了一个灵活、可扩展且易于使用的密码学服务框架。&lt;/p&gt;&lt;h2&gt;3. JCA 核心概念与类&lt;/h2&gt;
&lt;p&gt;了解了 JCA 的 Provider 架构和引擎类/SPI 机制后，接下来我们将聚焦于 JCA 中提供各种密码学功能的具体核心类和接口。它们是您在编写安全相关代码时将直接打交道的构建块。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 安全随机数生成：&lt;code&gt;SecureRandom&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在密码学中，随机性至关重要，尤其是在生成密钥、初始化向量 (IV) 等场景。&lt;code&gt;java.security.SecureRandom&lt;/code&gt; 类是一个引擎类，专门用于生成加密强度高、不可预测的随机数。与普通的 &lt;code&gt;java.lang.Random&lt;/code&gt; 不同，&lt;code&gt;SecureRandom&lt;/code&gt; 生成的随机数更难以被攻击者预测，从而增强了安全性。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 通常可以使用无参构造函数 &lt;code&gt;new SecureRandom()&lt;/code&gt; 获取默认的强随机数生成器，或者使用 &lt;code&gt;getInstance()&lt;/code&gt; 方法获取特定算法的实现，甚至可以通过 &lt;code&gt;getInstanceStrong()&lt;/code&gt; 获取由系统属性指定的“最强”实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置种子：&lt;/strong&gt; 可以使用 &lt;code&gt;setSeed()&lt;/code&gt; 方法为生成器设置种子，这有助于初始化生成器的内部状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成随机字节：&lt;/strong&gt; 主要通过 &lt;code&gt;nextBytes(byte[] bytes)&lt;/code&gt; 方法将随机字节填充到指定的字节数组中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 消息摘要：&lt;code&gt;MessageDigest&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;消息摘要（或称哈希、散列）是一种将任意长度的数据映射为固定长度“指纹”的技术。在 JCA 中，&lt;code&gt;java.security.MessageDigest&lt;/code&gt; 类提供了消息摘要的功能。消息摘要的主要特性是微小的数据改动都会导致摘要值发生显著变化，且从摘要值反推出原始数据在计算上是不可行的（单向性）。这使得它非常适合用于验证数据的完整性。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 使用 &lt;code&gt;getInstance(String algorithm)&lt;/code&gt; 方法获取特定算法（如 &amp;quot;SHA-256&amp;quot;、&amp;quot;MD5&amp;quot;）的 &lt;code&gt;MessageDigest&lt;/code&gt; 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理数据：&lt;/strong&gt; 通过 &lt;code&gt;update(byte[] input)&lt;/code&gt; 或 &lt;code&gt;update(byte[] input, int offset, int len)&lt;/code&gt; 方法向摘要对象提供待处理的数据。可以分多次调用 &lt;code&gt;update&lt;/code&gt; 来处理大量数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算摘要：&lt;/strong&gt; 调用 &lt;code&gt;digest()&lt;/code&gt; 方法完成计算并返回最终的摘要字节数组。&lt;code&gt;digest()&lt;/code&gt; 方法调用后，&lt;code&gt;MessageDigest&lt;/code&gt; 对象会自动重置，可以用于计算新的数据的摘要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 数字签名：&lt;code&gt;Signature&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数字签名用于验证数据的来源和完整性。在 JCA 中，&lt;code&gt;java.security.Signature&lt;/code&gt; 类提供了数字签名和验证的功能。签名过程通常使用私钥对数据的哈希值进行加密生成签名，验证过程则使用对应的公钥解密签名，并与待验证数据的哈希值进行比对。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Signature&lt;/code&gt; 对象具有不同的状态：未初始化、签名（SIGN）和验证（VERIFY）。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 使用 &lt;code&gt;getInstance(String algorithm)&lt;/code&gt; 方法获取特定签名算法（如 &amp;quot;SHA256withDSA&amp;quot;、&amp;quot;SHA256withRSA&amp;quot;）的 &lt;code&gt;Signature&lt;/code&gt; 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;签名：&lt;/strong&gt; 使用私钥通过 &lt;code&gt;initSign(PrivateKey privateKey)&lt;/code&gt; 方法初始化对象为签名状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证：&lt;/strong&gt; 使用公钥通过 &lt;code&gt;initVerify(PublicKey publicKey)&lt;/code&gt; 或 &lt;code&gt;initVerify(Certificate certificate)&lt;/code&gt; 方法初始化对象为验证状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理数据：&lt;/strong&gt; 在签名或验证状态下，使用 &lt;code&gt;update(byte[] data)&lt;/code&gt; 方法向对象提供待签名或验证的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行操作：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;签名：&lt;/strong&gt; 调用 &lt;code&gt;sign()&lt;/code&gt; 方法生成数字签名，返回签名字节数组。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证：&lt;/strong&gt; 调用 &lt;code&gt;verify(byte[] signature)&lt;/code&gt; 方法，传入待验证的签名，返回一个布尔值表示签名是否有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 加解密：&lt;code&gt;Cipher&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;加解密是保护数据机密性的手段，在 JCA 中，&lt;code&gt;javax.crypto.Cipher&lt;/code&gt; 类提供了加解密功能。它支持对称加密（使用同一个密钥进行加解密）和非对称加密（使用公私钥对进行加解密），以及块加密和流加密等多种模式。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 使用 &lt;code&gt;getInstance(String transformation)&lt;/code&gt; 方法获取 &lt;code&gt;Cipher&lt;/code&gt; 实例。这里的 &lt;code&gt;transformation&lt;/code&gt; 是一个字符串，通常格式为 &amp;quot;算法名称/模式/填充方式&amp;quot;（例如 &amp;quot;AES/CBC/PKCS5Padding&amp;quot;）或仅算法名称（例如 &amp;quot;AES&amp;quot;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化：&lt;/strong&gt; 使用 &lt;code&gt;init()&lt;/code&gt; 方法初始化 &lt;code&gt;Cipher&lt;/code&gt; 对象，需要指定操作模式（&lt;code&gt;Cipher.ENCRYPT_MODE&lt;/code&gt; 或 &lt;code&gt;Cipher.DECRYPT_MODE&lt;/code&gt;）、密钥，以及可选的算法参数（如初始化向量 IV）和随机源。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;init(int opmode, Key key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init(int opmode, Key key, AlgorithmParameterSpec params)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理数据：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单步操作：&lt;/strong&gt; 对于少量数据，可以直接使用 &lt;code&gt;doFinal(byte[] input)&lt;/code&gt; 或 &lt;code&gt;doFinal(byte[] input, int inputOffset, int inputLen)&lt;/code&gt; 方法进行一步加解密。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多步操作：&lt;/strong&gt; 对于大量数据或流式处理，可以使用 &lt;code&gt;update(byte[] input)&lt;/code&gt; 方法分块处理数据，最后调用 &lt;code&gt;doFinal()&lt;/code&gt; 方法完成最终的加解密和处理剩余数据（包括填充/去填充）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;辅助类：&lt;/strong&gt; JCA 还提供了 &lt;code&gt;CipherInputStream&lt;/code&gt; 和 &lt;code&gt;CipherOutputStream&lt;/code&gt; 用于流式加解密，以及 &lt;code&gt;SealedObject&lt;/code&gt; 用于封装和保护可序列化的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 密钥表示与管理：&lt;code&gt;Key&lt;/code&gt;, &lt;code&gt;KeySpec&lt;/code&gt;, &lt;code&gt;KeyFactory&lt;/code&gt;, &lt;code&gt;KeyGenerator&lt;/code&gt;, &lt;code&gt;KeyPairGenerator&lt;/code&gt;, &lt;code&gt;KeyStore&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;密钥是密码学操作的核心要素，JCA 提供了一系列类和接口来表示、生成和管理密钥。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;密钥接口 (&lt;code&gt;Key&lt;/code&gt;, &lt;code&gt;PublicKey&lt;/code&gt;, &lt;code&gt;PrivateKey&lt;/code&gt;, &lt;code&gt;SecretKey&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.Key&lt;/code&gt; 是所有密钥的不透明表示的顶级接口。它定义了密钥的三个基本属性：算法 (&lt;code&gt;getAlgorithm()&lt;/code&gt;)、编码格式 (&lt;code&gt;getFormat()&lt;/code&gt;) 和编码后的字节 (&lt;code&gt;getEncoded()&lt;/code&gt;)。&lt;code&gt;PublicKey&lt;/code&gt; 和 &lt;code&gt;PrivateKey&lt;/code&gt; 分别表示非对称密钥对中的公钥和私钥，&lt;code&gt;javax.crypto.SecretKey&lt;/code&gt; 表示对称密钥或秘密密钥。这里的“不透明”意味着您通常无法直接访问构成密钥的具体数值，而是将其作为一个整体对象使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥对 (&lt;code&gt;KeyPair&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.KeyPair&lt;/code&gt; 是一个简单的容器类，用于持有配对的公钥 (&lt;code&gt;getPublic()&lt;/code&gt;) 和私钥 (&lt;code&gt;getPrivate()&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥规范 (&lt;code&gt;KeySpec&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.spec.KeySpec&lt;/code&gt; 接口及其实现类提供了密钥材料的“透明”表示。透明表示允许您访问构成密钥的具体数值。例如，&lt;code&gt;DSAPrivateKeySpec&lt;/code&gt; 允许访问 DSA 私钥的各个组成部分（x, p, q, g）。&lt;code&gt;EncodedKeySpec&lt;/code&gt; 的子类（如 &lt;code&gt;PKCS8EncodedKeySpec&lt;/code&gt; 和 &lt;code&gt;X509EncodedKeySpec&lt;/code&gt;）表示密钥的编码格式（如 PKCS#8 用于私钥，X.509 用于公钥）。&lt;code&gt;javax.crypto.spec.SecretKeySpec&lt;/code&gt; 是一个常用的类，可以用字节数组和算法名称直接构造一个 &lt;code&gt;SecretKey&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥工厂 (&lt;code&gt;KeyFactory&lt;/code&gt;, &lt;code&gt;SecretKeyFactory&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.KeyFactory&lt;/code&gt;（用于公钥/私钥）和 &lt;code&gt;javax.crypto.SecretKeyFactory&lt;/code&gt;（用于秘密密钥）是引擎类，用于在密钥的&lt;strong&gt;不透明表示 (&lt;code&gt;Key&lt;/code&gt;)&lt;/strong&gt; 和&lt;strong&gt;透明表示 (&lt;code&gt;KeySpec&lt;/code&gt;)&lt;/strong&gt; 之间进行转换。它们可以从 &lt;code&gt;KeySpec&lt;/code&gt; 生成 &lt;code&gt;Key&lt;/code&gt; 对象（&lt;code&gt;generatePublic/Private/Secret(KeySpec keySpec)&lt;/code&gt;），也可以从 &lt;code&gt;Key&lt;/code&gt; 对象获取相应的 &lt;code&gt;KeySpec&lt;/code&gt;（&lt;code&gt;getKeySpec(Key key, Class keySpec)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥生成器 (&lt;code&gt;KeyGenerator&lt;/code&gt;, &lt;code&gt;KeyPairGenerator&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;javax.crypto.KeyGenerator&lt;/code&gt;（用于秘密密钥）和 &lt;code&gt;java.security.KeyPairGenerator&lt;/code&gt;（用于密钥对）是引擎类，用于&lt;strong&gt;生成全新的密钥&lt;/strong&gt;。您可以指定密钥大小和随机源来初始化生成器，然后调用 &lt;code&gt;generateKey()&lt;/code&gt; 或 &lt;code&gt;generateKeyPair()&lt;/code&gt; 生成密钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥库 (&lt;code&gt;KeyStore&lt;/code&gt;)&lt;/strong&gt;: &lt;code&gt;java.security.KeyStore&lt;/code&gt; 是一个重要的引擎类，提供了一个抽象接口来访问和管理密钥和证书的存储库。它可以用于持久化存储私钥、秘密密钥和可信证书。常见的密钥库类型包括 &amp;quot;jks&amp;quot; (Java KeyStore, 专有格式) 和 &amp;quot;pkcs12&amp;quot; (基于 PKCS#12 标准，更通用)。&lt;code&gt;KeyStore&lt;/code&gt; 提供了加载 (&lt;code&gt;load()&lt;/code&gt;)、获取条目 (&lt;code&gt;getEntry()&lt;/code&gt;)、设置条目 (&lt;code&gt;setEntry()&lt;/code&gt;) 和保存 (&lt;code&gt;store()&lt;/code&gt;) 等方法来操作密钥库中的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6. 证书与 CRL：&lt;code&gt;CertificateFactory&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;证书是用于验证公钥所有者身份的数字文档，通常由证书颁发机构 (CA) 签名。证书吊销列表 (CRL) 列出了已被吊销的证书。&lt;code&gt;java.security.cert.CertificateFactory&lt;/code&gt; 是一个引擎类，用于从编码格式（如 X.509）生成证书和 CRL 对象。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建实例：&lt;/strong&gt; 使用 &lt;code&gt;getInstance(String type)&lt;/code&gt; 方法获取特定证书类型（如 &amp;quot;X.509&amp;quot;）的 &lt;code&gt;CertificateFactory&lt;/code&gt; 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成证书/CRL：&lt;/strong&gt; 通过 &lt;code&gt;generateCertificate(InputStream inStream)&lt;/code&gt; 或 &lt;code&gt;generateCertificates(InputStream inStream)&lt;/code&gt; 从输入流中读取数据并生成证书对象或集合。类似地，使用 &lt;code&gt;generateCRL(InputStream inStream)&lt;/code&gt; 或 &lt;code&gt;generateCRLs(InputStream inStream)&lt;/code&gt; 生成 CRL 对象或集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;掌握了这些核心类和接口的功能，您就掌握了使用 JCA 构建安全应用的基石。在接下来的部分，我们将通过具体的代码示例，演示如何利用其中的一些类来实现常见的密码学操作。&lt;/p&gt;&lt;h2&gt;4. 常见 JCA 功能使用示例&lt;/h2&gt;
&lt;p&gt;掌握了 JCA 的架构和核心类之后，是时候通过实际代码来感受它的强大之处了。本节将演示如何在 Java 应用程序中实现最常见的密码学操作。&lt;/p&gt;&lt;h3&gt;消息摘要（Hashing）&lt;/h3&gt;
&lt;p&gt;消息摘要用于验证数据的完整性。它将任意长度的数据转化为固定长度的“指纹”。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心类：&lt;/strong&gt; &lt;code&gt;java.security.MessageDigest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例场景：&lt;/strong&gt; 计算一个字符串的 SHA-256 摘要。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.MessageDigest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.NoSuchAlgorithmException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.nio.charset.StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.Base64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MessageDigestExample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;originalMessage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello, JCA! This is a test message.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;原始消息: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;originalMessage&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 1. 获取MessageDigest实例，指定算法为SHA-256&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 2. 更新数据：将字符串转换为字节数组并提供给摘要对象&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encodedhash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;originalMessage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 3. 将字节数组转换为十六进制字符串或Base64字符串以便显示&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bytesToHex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encodedhash&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;base64String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;encodeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encodedhash&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256 摘要 (Hex): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA-256 摘要 (Base64): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;base64String&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 验证完整性：如果原始消息稍有改动，摘要值会完全不同&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;changedMessage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello, JCA! This is a test message. (changed)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;changedHash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;changedMessage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;修改后消息的 SHA-256 摘要 (Hex): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bytesToHex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;changedHash&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NoSuchAlgorithmException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;err&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;指定的算法不存在: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 辅助方法：将字节数组转换为十六进制字符串&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;bytesToHex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toHexString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hexString&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;通过 &lt;code&gt;MessageDigest.getInstance(&amp;quot;SHA-256&amp;quot;)&lt;/code&gt; 获取一个 SHA-256 算法的 &lt;code&gt;MessageDigest&lt;/code&gt; 实例。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;digest.digest()&lt;/code&gt; 方法，将输入数据的字节数组传递给它。这个方法会计算摘要并返回字节数组。注意，&lt;code&gt;digest()&lt;/code&gt; 调用后，&lt;code&gt;MessageDigest&lt;/code&gt; 对象会自动重置，可以用于处理下一段数据。&lt;/li&gt;
&lt;li&gt;我们使用 &lt;code&gt;bytesToHex&lt;/code&gt; 辅助方法和 &lt;code&gt;Base64.getEncoder()&lt;/code&gt; 将字节数组形式的摘要转换为可读的十六进制或 Base64 字符串。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;数字签名（Digital Signature）&lt;/h3&gt;
&lt;p&gt;数字签名用于验证数据的来源和完整性，确保数据在传输过程中未被篡改，并且确实由声称的发送方发出。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心类：&lt;/strong&gt; &lt;code&gt;java.security.KeyPairGenerator&lt;/code&gt;, &lt;code&gt;java.security.Signature&lt;/code&gt;, &lt;code&gt;java.security.PublicKey&lt;/code&gt;, &lt;code&gt;java.security.PrivateKey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例场景：&lt;/strong&gt; 使用 RSA 算法对消息进行签名和验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.nio.charset.StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.Base64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DigitalSignatureExample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;This is the original message to be signed.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;原始消息: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 1. 生成密钥对 (公钥和私钥) ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 适用于非对称加密和数字签名&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;KeyPairGenerator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPairGen&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;KeyPairGenerator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;RSA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;keyPairGen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2048&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 初始化密钥生成器，指定密钥长度&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;KeyPair&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPair&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPairGen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;generateKeyPair&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 生成密钥对&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;PublicKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;publicKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPair&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getPublic&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;PrivateKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;privateKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyPair&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getPrivate&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 数字签名过程 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 2. 签名数据 ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;Signature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA256withRSA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 指定签名算法&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initSign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;privateKey&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 用私钥初始化签名对象&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 提供待签名的数据&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;digitalSignature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 生成数字签名&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;生成的数字签名 (Base64): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;encodeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitalSignature&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 数字签名验证过程 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 3. 验证签名 ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;Signature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Signature&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SHA256withRSA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 同样使用签名算法&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initVerify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;publicKey&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 用公钥初始化验证对象&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 提供原始消息数据&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verified&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitalSignature&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 验证签名&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;签名验证结果: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;verified&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;成功&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 尝试篡改消息后验证&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 尝试篡改消息后验证 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tamperedMessage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;This is the original message to be signed. (TAMPERED)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initVerify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;publicKey&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 重新初始化验证对象&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tamperedMessage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 提供被篡改的消息&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tamperedVerified&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verifier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;verify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;digitalSignature&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;篡改后签名验证结果: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tamperedVerified&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;成功&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NoSuchAlgorithmException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;InvalidKeyException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SignatureException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;err&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;发生错误: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;生成密钥对：&lt;/strong&gt; 使用 &lt;code&gt;KeyPairGenerator.getInstance(&amp;quot;RSA&amp;quot;)&lt;/code&gt; 获取 RSA 密钥对生成器，并指定密钥长度（2048位）。&lt;code&gt;generateKeyPair()&lt;/code&gt; 方法生成包含公钥和私钥的 &lt;code&gt;KeyPair&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;签名：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;Signature.getInstance(&amp;quot;SHA256withRSA&amp;quot;)&lt;/code&gt; 获取签名实例，&amp;quot;SHA256withRSA&amp;quot; 表示使用 SHA-256 算法对数据进行哈希，然后用 RSA 算法进行签名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initSign(privateKey)&lt;/code&gt; 用私钥初始化签名对象，进入签名模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update()&lt;/code&gt; 传入需要签名的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sign()&lt;/code&gt; 生成最终的数字签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;同样通过 &lt;code&gt;Signature.getInstance(&amp;quot;SHA256withRSA&amp;quot;)&lt;/code&gt; 获取签名实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initVerify(publicKey)&lt;/code&gt; 用公钥初始化验证对象，进入验证模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update()&lt;/code&gt; 传入&lt;strong&gt;原始的&lt;/strong&gt;（未篡改的）数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;verify(digitalSignature)&lt;/code&gt; 传入收到的数字签名。如果数据未被篡改且签名有效，将返回 &lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;加解密（Encryption/Decryption）&lt;/h3&gt;
&lt;p&gt;加解密用于保护数据的机密性，防止未授权访问。这里我们以常用的对称加密算法 AES 为例。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心类：&lt;/strong&gt; &lt;code&gt;javax.crypto.KeyGenerator&lt;/code&gt;, &lt;code&gt;javax.crypto.Cipher&lt;/code&gt;, &lt;code&gt;javax.crypto.spec.SecretKeySpec&lt;/code&gt;, &lt;code&gt;javax.crypto.spec.IvParameterSpec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例场景：&lt;/strong&gt; 使用 AES/CBC/PKCS5Padding 模式对字符串进行加解密。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.Cipher&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.KeyGenerator&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.SecretKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.spec.IvParameterSpec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.spec.SecretKeySpec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.nio.charset.StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.NoSuchAlgorithmException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.InvalidKeyException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.InvalidAlgorithmParameterException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.NoSuchPaddingException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.BadPaddingException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;javax.crypto.IllegalBlockSizeException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.security.SecureRandom&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;java.util.Base64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EncryptionDecryptionExample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// AES 加密/解密使用的转换模式&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TRANSFORMATION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;AES/CBC/PKCS5Padding&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ALGORITHM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;AES&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;originalText&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello, JCA! This is a secret message to be encrypted.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;原始文本: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;originalText&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 1. 生成密钥和初始化向量 (IV) ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 对于对称加密，我们需要一个秘密密钥&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;KeyGenerator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyGen&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;KeyGenerator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ALGORITHM&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;keyGen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// AES支持128, 192, 256位密钥&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;SecretKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secretKey&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;keyGen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;generateKey&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 对于CBC模式，需要一个随机的初始化向量 (IV)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;SecureRandom&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secureRandom&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// AES块大小为16字节&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;secureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;nextBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;IvParameterSpec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ivSpec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IvParameterSpec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 数据加密过程 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 2. 加密数据 ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TRANSFORMATION&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ENCRYPT_MODE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secretKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ivSpec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 初始化为加密模式，传入密钥和IV&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encryptedBytes&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;doFinal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;originalText&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encryptedTextBase64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;encodeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encryptedBytes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ivBase64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;encodeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// IV也需要传输给解密方&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;加密后的文本 (Base64): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encryptedTextBase64&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;使用的 IV (Base64): &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ivBase64&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;\n--- 数据解密过程 ---&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// --- 3. 解密数据 ---&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 解密时需要相同的密钥和IV&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;retrievedIv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDecoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ivBase64&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 从传输中获取IV&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;IvParameterSpec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;retrievedIvSpec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IvParameterSpec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;retrievedIv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;DECRYPT_MODE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secretKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;retrievedIvSpec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 初始化为解密模式，传入密钥和IV&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decryptedBytes&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;doFinal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDecoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encryptedTextBase64&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decryptedText&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decryptedBytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;StandardCharsets&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;UTF_8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;解密后的文本: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decryptedText&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NoSuchAlgorithmException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NoSuchPaddingException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;InvalidKeyException&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;InvalidAlgorithmParameterException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IllegalBlockSizeException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BadPaddingException&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;err&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;发生错误: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;生成密钥和 IV：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KeyGenerator.getInstance(&amp;quot;AES&amp;quot;)&lt;/code&gt; 获取 AES 密钥生成器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keyGen.init(256)&lt;/code&gt; 初始化生成器，指定密钥长度为 256 位（AES 支持 128, 192, 256）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;generateKey()&lt;/code&gt; 生成 &lt;code&gt;SecretKey&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对于 CBC 模式（或任何块模式），还需要一个随机的&lt;strong&gt;初始化向量 (IV)&lt;/strong&gt;。&lt;code&gt;SecureRandom&lt;/code&gt; 用于生成加密安全的随机 IV，其长度通常与算法的块大小（AES 为 16 字节）相同。&lt;code&gt;IvParameterSpec&lt;/code&gt; 用于封装 IV。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加密：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Cipher.getInstance(&amp;quot;AES/CBC/PKCS5Padding&amp;quot;)&lt;/code&gt; 获取 &lt;code&gt;Cipher&lt;/code&gt; 实例。这里的 &lt;code&gt;&amp;quot;AES/CBC/PKCS5Padding&amp;quot;&lt;/code&gt; 指定了算法（AES）、操作模式（CBC，密文分组链接模式）和填充方式（PKCS5Padding）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec)&lt;/code&gt; 将 &lt;code&gt;Cipher&lt;/code&gt; 初始化为加密模式，传入之前生成的 &lt;code&gt;SecretKey&lt;/code&gt; 和 &lt;code&gt;IvParameterSpec&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cipher.doFinal()&lt;/code&gt; 执行最终的加密操作，返回加密后的字节数组。我们将其转换为 Base64 字符串以便于显示和传输。&lt;strong&gt;请注意，在实际应用中，IV 也必须安全地与密文一起传输给接收方。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解密：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;解密时，需要使用与加密时&lt;strong&gt;相同的密钥&lt;/strong&gt;和&lt;strong&gt;相同的 IV&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cipher.init(Cipher.DECRYPT_MODE, secretKey, retrievedIvSpec)&lt;/code&gt; 将 &lt;code&gt;Cipher&lt;/code&gt; 初始化为解密模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cipher.doFinal()&lt;/code&gt; 执行解密操作，返回原始数据的字节数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好的，我们来完成博客的“总结”部分。这部分将回顾 JCA 的重要性，并对全文进行概括。&lt;/p&gt;&lt;h2&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;通过本文的介绍，相信您已经对 Java 密码学架构（JCA）有了更深入的理解。我们从 JCA 的核心设计理念——&lt;strong&gt;实现独立性、实现互操作性&lt;/strong&gt;和&lt;strong&gt;算法可扩展性&lt;/strong&gt;入手，详细探讨了其&lt;strong&gt;Provider 架构&lt;/strong&gt;以及&lt;strong&gt;引擎类与 SPI&lt;/strong&gt; 的工作机制，它们共同构成了 JCA 强大而灵活的基础。&lt;/p&gt;&lt;p&gt;我们还详细介绍了 JCA 中的一系列核心类和接口，它们是您在编写安全相关代码时的重要工具，包括用于生成安全随机数的 &lt;code&gt;SecureRandom&lt;/code&gt;，验证数据完整性的 &lt;code&gt;MessageDigest&lt;/code&gt;，实现身份认证和防篡改的 &lt;code&gt;Signature&lt;/code&gt;，以及保障数据机密性的 &lt;code&gt;Cipher&lt;/code&gt;。最后，通过实际的 Java 代码示例，我们演示了如何利用这些类来完成消息摘要、数字签名和数据加解密这些常见的密码学操作。&lt;/p&gt;&lt;p&gt;JCA 的核心价值在于它提供了一个标准化的、可插拔的框架，使得开发者能够轻松地在应用程序中集成多样化的密码学功能，而无需陷入底层算法实现的复杂细节。这意味着您可以灵活地选择不同的 Provider，利用最新的算法或硬件加速，同时保持应用程序代码的高度可移植性。&lt;/p&gt;&lt;p&gt;然而，密码学是一个复杂且不断发展的领域。虽然 JCA 极大地简化了密码学功能的使用，但在实际的生产环境中，仍然需要对所选算法的特性、密钥管理策略、数据传输安全等有深入的理解，并遵循最新的安全最佳实践。&lt;/p&gt;</description><author>im.wuxiaoyuan@gmail.com (wuxiaoyuan)</author><guid isPermaLink="true">/archives/JCA-essentials/</guid><pubDate>Fri, 16 May 2025 22:08:57 +0806</pubDate></item><item><title>Static Factory Method and Builder Pattern</title><link>/archives/static-factory-method-and-buidler-pattern/</link><description>&lt;h1&gt;深入探索静态工厂方法与构建器模式&lt;/h1&gt;
&lt;p&gt;在 Java 编程中，创建和销毁对象是基础操作。虽然公共构造函数 (public constructor) 是创建对象实例最常见的方式，但它并非总是最佳选择。本文将深入探讨两种强大的技术——静态工厂方法 (static factory methods) 和构建器模式 (Builder pattern)——它们可以使您的对象创建过程更加灵活、可读且易于维护 ，这些方法应该成为每个程序员工具箱的一部分 。&lt;/p&gt;&lt;h2&gt;1. 传统构造函数的局限性&lt;/h2&gt;
&lt;p&gt;长久以来，公共构造函数是实例化对象的标准途径 。然而，随着应用程序逻辑的日趋复杂，它们的一些不足也愈发明显：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缺乏描述性名称&lt;/strong&gt;：构造函数的名称必须与类名相同。当参数列表本身不足以清晰描述被创建对象的特征或用途时，仅凭构造函数名称，开发者可能难以直观理解对象的创建逻辑 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无法灵活控制实例创建&lt;/strong&gt;：构造函数在每次调用时，通常必须创建一个新的对象 。它们本身不提供返回现有实例（如缓存实例或共享实例）或返回其声明类型的子类型实例的机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;难以应对大量可选参数&lt;/strong&gt;：当一个类拥有众多可选参数时，依赖构造函数会导致代码笨拙。开发者可能被迫使用“伸缩构造函数模式” (telescoping constructor pattern)，即提供多个构造函数，每个构造函数都比前一个多一个可选参数 。这种模式下，客户端代码会变得冗长且难以阅读和维护 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些局限性促使我们寻求更优的对象创建策略。&lt;/p&gt;&lt;h2&gt;2. 静态工厂方法&lt;/h2&gt;
&lt;p&gt;作为构造函数的一种替代方案，类可以提供公共静态工厂方法 (public static factory method) 。这是一种简单的静态方法，其职责是返回类的实例 。例如，&lt;code&gt;Boolean.valueOf(boolean b)&lt;/code&gt; 就是一个将布尔基本类型转换为 &lt;code&gt;Boolean&lt;/code&gt; 对象的静态工厂方法 。&lt;/p&gt;&lt;h3&gt;静态工厂方法的优势&lt;/h3&gt;
&lt;p&gt;相较于构造函数，静态工厂方法具备多项显著优势。&lt;/p&gt;&lt;h4&gt;具有描述性名称&lt;/h4&gt;
&lt;p&gt;静态工厂方法的一个优势在于它们具有名称，这一点与构造函数不同。如果构造函数的参数本身无法明确描述所返回的对象，那么一个命名恰当的静态工厂方法会更便于使用，且使用该方法的客户端代码也更易于阅读。例如，&lt;code&gt;BigInteger(int, int, Random)&lt;/code&gt; 这个构造函数虽然返回的可能是素数，但若改用名为&lt;code&gt;BigInteger.probablePrime&lt;/code&gt;的静态工厂方法（该方法在Java 4中加入）来表达会更加清晰。&lt;/p&gt;&lt;p&gt;一个类对于给定的方法签名只能有一个构造函数。程序员们通常通过提供两个仅在参数类型顺序上有所区别的构造函数来绕过这一限制，但这种做法非常糟糕。使用此类API的开发人员永远无法记住各个构造函数的区别，最终往往会错误地调用不合适的构造函数。阅读使用这些构造函数的代码时，如果不查阅类文档，其他人根本无法理解代码的实际功能。由于具有名称特性，静态工厂方法不受此限制的约束。当类需要多个相同签名的构造函数时，应当用静态工厂方法替代这些构造函数，并通过选择合适的命名来突显它们之间的差异。&lt;/p&gt;&lt;h4&gt;无需每次都创建新对象&lt;/h4&gt;
&lt;p&gt;静态工厂方法在被调用时，并非必须创建一个全新的对象 。它们可以返回预先构建好的实例，或者缓存并重用之前创建的实例，从而避免不必要的对象创建开销 。这对于不可变类 (immutable classes) 尤其有用，类似于享元模式 (Flyweight pattern) 。例如，&lt;code&gt;Boolean.valueOf(boolean)&lt;/code&gt; 方法从不创建新对象 。这种特性也使得类能够实现“实例控制” (instance-controlled)，例如保证类是单例 (singleton) 、不可实例化 (noninstantiable) 等。&lt;/p&gt;&lt;h4&gt;可以返回其返回类型的任何子类型&lt;/h4&gt;
&lt;p&gt;静态工厂方法可以返回其声明返回类型的任何子类型的对象 。这提供了极大的灵活性，例如 API 可以返回对象而不公开其具体类，从而形成一个非常紧凑的 API 。这在基于接口的框架中很常见 。例如，Java 集合框架 (Java Collections Framework) 在 &lt;code&gt;java.util.Collections&lt;/code&gt; 中使用静态工厂方法导出了其接口的45个实用工具实现，而返回对象的类都是非公共的 。这不仅减小了 API 的体量，也降低了其概念权重 。从 Java 8 开始，接口可以直接拥有静态方法，减少了对此类伴生类 (companion class) 的需求 。然而，这些静态方法背后的实现代码可能仍需要放在单独的包级私有类中，因为 Java 8 要求接口的所有静态成员都必须是公共的（Java 9 允许私有静态方法，但接口中的静态字段和静态成员类仍需是公共的）。&lt;/p&gt;&lt;h4&gt;可根据输入参数改变返回对象的类型&lt;/h4&gt;
&lt;p&gt;静态工厂方法可以根据传入参数的不同，动态地决定并返回不同子类的实例 。例如，&lt;code&gt;EnumSet&lt;/code&gt; 类没有公共构造函数，完全依赖静态工厂方法创建实例 。在 OpenJDK 的实现中，如果底层的枚举类型元素少于等于64个，静态工厂会返回一个由单个 &lt;code&gt;long&lt;/code&gt; 支持的 &lt;code&gt;RegularEnumSet&lt;/code&gt; 实例；如果元素超过64个，则返回一个由 &lt;code&gt;long&lt;/code&gt; 数组支持的 &lt;code&gt;JumboEnumSet&lt;/code&gt; 实例 。客户端对这些内部实现类的存在是无感的 。&lt;/p&gt;&lt;h4&gt;服务提供者框架的基础&lt;/h4&gt;
&lt;p&gt;使用静态工厂方法时，返回对象的具体类在包含该方法的类被编写时甚至可以不必存在 。这种灵活性是服务提供者框架 (service provider frameworks) 的核心，例如 JDBC 。一个服务提供者框架通常包含服务接口 (service interface，代表一种实现) ，提供者注册 API (provider registration API，提供者用以注册实现) ，以及服务访问 API (service access API，客户端用以获取服务实例) ——后者通常就是一种灵活的静态工厂。例如，在 JDBC 中，&lt;code&gt;Connection&lt;/code&gt; 扮演服务接口的角色，&lt;code&gt;DriverManager.registerDriver&lt;/code&gt; 是提供者注册 API，&lt;code&gt;DriverManager.getConnection&lt;/code&gt; 是服务访问 API 。自 Java 6 起，平台提供了一个通用的服务提供者框架 &lt;code&gt;java.util.ServiceLoader&lt;/code&gt; 。&lt;/p&gt;&lt;h3&gt;静态工厂方法的局限性&lt;/h3&gt;
&lt;h4&gt;子类化问题&lt;/h4&gt;
&lt;p&gt;如果一个类没有提供公共的或受保护的构造函数，而只提供静态工厂方法来获取实例，那么这个类通常不能被子类化 。例如，Java 集合框架中的所有便捷实现类都不能被子类化 。不过，这有时反而是件好事，因为它鼓励开发者使用组合 (composition) 而非继承 (inheritance) 。&lt;/p&gt;&lt;h4&gt;可发现性较差&lt;/h4&gt;
&lt;p&gt;与构造函数相比，静态工厂方法在 API 文档中可能不易被发现 。清晰的文档说明以及遵守通用的命名约定有助于缓解这个问题 。常见的约定包括：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;from&lt;/code&gt;：类型转换方法，接受单个参数并返回此类型的相应实例 (例如：&lt;code&gt;Date d = Date.from(instant);&lt;/code&gt;) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;of&lt;/code&gt;：聚合方法，接受多个参数并返回包含这些参数的此类型实例 (例如：&lt;code&gt;Set&amp;lt;Rank&amp;gt; faceCards = EnumSet.of(JACK, QUEEN, KING);&lt;/code&gt;) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;valueOf&lt;/code&gt;：&lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;of&lt;/code&gt; 更冗长的替代方法 (例如：&lt;code&gt;BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);&lt;/code&gt;) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;instance&lt;/code&gt; 或 &lt;code&gt;getInstance&lt;/code&gt;：返回由其参数（如果有）描述的实例，但可能不是同一个 (例如：&lt;code&gt;StackWalker luke = StackWalker.getInstance(options);&lt;/code&gt;) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;create&lt;/code&gt; 或 &lt;code&gt;newInstance&lt;/code&gt;：与 &lt;code&gt;instance&lt;/code&gt; 或 &lt;code&gt;getInstance&lt;/code&gt; 类似，但该方法保证每次调用都返回一个新实例 (例如：&lt;code&gt;Object newArray = Array.newInstance(classObject, arrayLen);&lt;/code&gt;) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;getType&lt;/code&gt;：与 &lt;code&gt;getInstance&lt;/code&gt; 类似，但在工厂方法位于不同类中时使用。&lt;code&gt;Type&lt;/code&gt; 是工厂方法返回的对象的类型 (例如：&lt;code&gt;FileStore fs = Files.getFileStore(path);&lt;/code&gt;) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;newType&lt;/code&gt;：与 &lt;code&gt;newInstance&lt;/code&gt; 类似，但在工厂方法位于不同类中时使用。&lt;code&gt;Type&lt;/code&gt; 是工厂方法返回的对象的类型 (例如：&lt;code&gt;BufferedReader br = Files.newBufferedReader(path);&lt;/code&gt;) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;type&lt;/code&gt;：&lt;code&gt;getType&lt;/code&gt; 和 &lt;code&gt;newType&lt;/code&gt; 的简洁替代方法 (例如：&lt;code&gt;List&amp;lt;Complaint&amp;gt; litany = Collections.list(legacyLitany);&lt;/code&gt;) 。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在许多情况下，静态工厂优于公共构造函数，因此在默认使用公共构造函数之前，明智的做法是先考虑静态工厂 。&lt;/p&gt;&lt;h4&gt;处理大量可选参数的挑战&lt;/h4&gt;
&lt;p&gt;当面临大量可选参数时，静态工厂和构造函数都存在局限性，它们的可伸缩性不好 。想象一个用于表示食品包装上营养成分标签的类，它有一些必填字段（如每份的量）和超过二十个可选字段（如总脂肪、钠含量等）。&lt;/p&gt;&lt;p&gt;你将如何构造这类对象呢？&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;伸缩构造函数模式 (Telescoping Constructor Pattern)&lt;/strong&gt;：：这种模式提供一个只有必需参数的构造函数，然后是另一个带有一个可选参数的构造函数，再一个带有两个可选参数的，以此类推 ，这会导致客户端代码难以编写和阅读 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JavaBeans 模式&lt;/strong&gt;：另一种方法是提供一个无参构造函数，并通过 setter 方法逐个设置参数 。然而，这种模式的缺点在于构造过程被分解到多个调用中，对象在构造完成前可能处于不一致状态 。此外，它也阻碍了类成为不可变的可能性 ，并需要额外的工作来保证线程安全。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. 构建器模式 (Builder Pattern)&lt;/h2&gt;
&lt;p&gt;构建器模式是一种旨在安全性和可读性之间取得平衡的创建模式 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;构建器模式的工作原理：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;与直接创建目标对象不同，客户端首先调用一个构造函数（或静态工厂）并提供所有必需参数，以获取一个构建器 (builder) 对象 。然后，客户端在构建器对象上调用类似 setter 的方法来设置每个感兴趣的可选参数 。这些 setter 方法通常会返回构建器本身，以便进行链式调用，形成流式 API (fluent API) 。最后，客户端调用构建器对象上的一个无参 &lt;code&gt;build&lt;/code&gt; 方法来生成最终的（通常是不可变的）目标对象 。构建器本身通常是它所构建的类的静态成员类 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;构建器模式的优势：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;增强可读性&lt;/strong&gt;：通过链式调用和描述性的方法名，代码意图一目了然，近似于 Python 或 Scala 中的命名可选参数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用于类层次结构&lt;/strong&gt;：构建器模式可以很好地扩展到类层次结构中。通常的做法是为每个类建立一个并行的构建器层次结构，抽象类拥有抽象构建器，具体类拥有具体构建器 。这通常涉及到使用带有递归类型参数的泛型（模拟自身类型机制）和协变返回类型 (covariant return typing)，使得子类构建器的 &lt;code&gt;build&lt;/code&gt; 方法能返回正确的子类实例，而无需客户端进行类型转换 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活性&lt;/strong&gt;：构建器可以支持多个可变参数 (varargs)，因为每个参数都在其专属的方法中指定 。单个构建器实例也可以被重复使用来构建多个不同的对象 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数校验&lt;/strong&gt;：参数的有效性检查可以在构建器的构造函数和各个设置方法中进行 。涉及多个参数的约束条件可以在 &lt;code&gt;build&lt;/code&gt; 方法调用的最终构造函数中检查 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;构建器模式的潜在缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建构建器的成本&lt;/strong&gt;：为了创建目标对象，必须先创建其构建器 。虽然在大多数情况下这种开销微不足道，但在对性能极其敏感的场景下可能需要权衡 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相对冗余&lt;/strong&gt;：与伸缩构造函数相比，构建器模式的代码量更大，因此当参数数量不多时（例如少于四个），可能显得有些笨重 。但重要的是要考虑到类未来可能会增加更多参数的可能性 。如果一开始使用构造函数或静态工厂，当参数数量失控时再切换到构建器，那么那些过时的构造函数或静态工厂会显得极不协调 。因此，通常从一开始就使用构建器会更好 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;何时使用构建器：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当一个类的构造函数或静态工厂方法将拥有较多参数时，特别是当其中许多参数是可选的或类型相同时，构建器模式是一个绝佳的选择 。与伸缩构造函数相比，使用构建器的客户端代码更易于阅读和编写；与 JavaBeans 模式相比，构建器模式则要安全得多 。&lt;/p&gt;&lt;h2&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;静态工厂方法和构建器模式都是 Java 开发人员对象创建工具箱中的宝贵工具 。在许多场景下，尤其是在类复杂度增加时，它们相对于传统的公共构造函数，在代码可读性、灵活性和可维护性方面提供了显著的优势 。通过理解它们各自的优缺点，可以在设计类时做出更明智的决策，从而产生更健壮和用户友好的 API。因此，当下次准备编写公共构造函数时，请花点时间考虑一下静态工厂或构建器是否会是更好的选择 。&lt;/p&gt;</description><author>im.wuxiaoyuan@gmail.com (wuxiaoyuan)</author><guid isPermaLink="true">/archives/static-factory-method-and-buidler-pattern/</guid><pubDate>Sun, 25 May 2025 11:23:34 +0806</pubDate></item><item><title>How to write high-quality equals methods</title><link>/archives/high-quality-equals/</link><description>&lt;h1&gt;如何编写高质量的equals方法&lt;/h1&gt;
&lt;p&gt;Java类的equals方法用于判断两个对象实例是否相等，重写equals方法看似简单，但实则暗藏玄机，稍不注意便会酿成大错。&lt;/p&gt;&lt;p&gt;Object类的equals方法实现非常简单，它仅仅比较两个对象的引用是否指向同一个内存地址。也就是说，默认情况下，只有当两个对象是同一个实例时，equals方法才会返回true。&lt;/p&gt;&lt;p&gt;在实际应用中，默认实现一般不满足我们的需求，需要重写equals方法。但也存在一些例外情况，默认实现已经能满足相等性比较需求了，不需要进行重写，这些例外情况包括：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类的每个实例本质上都是唯一的。比如&lt;code&gt;Thread&lt;/code&gt;类，每个线程实例都是独一无二的，Object的equals方法实现对于这些类来说完全够用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类不需要提供“逻辑相等”功能。例如，&lt;code&gt;java.util.regex.Pattern&lt;/code&gt; 本可以覆盖 equals 来检查两个 Pattern 实例是否代表完全相同的正则表达式，但设计者认为客户端不需要或不想要此功能。在这种情况下，从 Object 继承的 equals 实现足够用了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;超类已经重写了equals方法，并且超类的行为对于该子类也是合适的。例如大多数的&lt;code&gt;Set&lt;/code&gt;实现类都继承了&lt;code&gt;AbstractSet&lt;/code&gt;的equals实现，&lt;code&gt;AbstractList&lt;/code&gt; 和 &lt;code&gt;AbstractMap&lt;/code&gt; 也类似，大多数子类都继承了它们各自的equals方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类是私有的或包级私有的，并且你确信其equals方法永远不会被调用。如果你担心意外发生，可以重写equals方法，让其抛出异常以防止意外地调用。&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AssertionError&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// equals方法永远不应被调用&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，什么情况下应该重写equals呢？当类需要提供“逻辑相等”概念，而超类尚未重写equals以实现此行为时，不要犹豫赶紧重写。通常值类（&lt;strong&gt;value class&lt;/strong&gt;）需要重写equals方法，比如像&lt;code&gt;Integer&lt;/code&gt;、&lt;code&gt;Long&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;，当比较这些类的实例时，我们想知道其表示的值或字符串是否相等，而不是它们是否指向同一个对象。另外，如果类实例可以作为Map的键（key）或Set的元素时，也要重写equals方法，以确保程序行为可预测且符合预期。&lt;/p&gt;&lt;h2&gt;equals方法的通用约定&lt;/h2&gt;
&lt;p&gt;重写equals方法时，必须遵守Object中描述的通用约定，包括自反性、对称性、传递性、一致性和非空性。&lt;/p&gt;&lt;h3&gt;自反性&lt;/h3&gt;
&lt;p&gt;对于任何非空的引用值&lt;code&gt;x&lt;/code&gt;，&lt;code&gt;x.equals(x)&lt;/code&gt; 必须返回true。这意味着一个对象必须等于它自己。&lt;/p&gt;&lt;h3&gt;对称性&lt;/h3&gt;
&lt;p&gt;对于任何非空的引用值 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，当且仅当 &lt;code&gt;x.equals(y)&lt;/code&gt; 返回true时，&lt;code&gt;y.equals(x)&lt;/code&gt; 也必须返回true。&lt;/p&gt;&lt;p&gt;要实现对称性看似容易，但稍不留神就可能违反此约定。&lt;/p&gt;&lt;p&gt;下面是一个表示不区分字符串大小写的类：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CaseInsensitiveString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;CaseInsensitiveString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Objects&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;requireNonNull&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 错误示范 - 违反了对称性!&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CaseInsensitiveString&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IgnoreCase&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;CaseInsensitiveString&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="na"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 单向互操作!&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ... 其余部分省略&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在让我们创建一个&lt;code&gt;CaseInsensitiveString&lt;/code&gt;实例和一个普通字符串实例：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;CaseInsensitiveString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cis&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CaseInsensitiveString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Tomcat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tomcat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行 &lt;code&gt;cis.equals(s)&lt;/code&gt; 时，结果返回true，但是 &lt;code&gt;s.equals(cis)&lt;/code&gt; 却返回false，因为&lt;code&gt;String&lt;/code&gt; 类不认识&lt;code&gt;CaseInsensitiveString&lt;/code&gt;，这明显违反了对称性约定。&lt;/p&gt;&lt;p&gt;要修复此问题，只需从 equals 方法中删除与 String 互操作的错误尝试：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CaseInsensitiveString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;CaseInsensitiveString&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="na"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;传递性&lt;/h3&gt;
&lt;p&gt;对于任何非空的引用值 &lt;code&gt;x&lt;/code&gt; ,&lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; ，如果 &lt;code&gt;x.equals(y)&lt;/code&gt; 返回true且 &lt;code&gt;y.equals(z)&lt;/code&gt; 返回true时，那么 x.equals(z) 也必须返回true。&lt;/p&gt;&lt;p&gt;在实践中，我们自己实现equals方法时很容易违反这一条约定。&lt;/p&gt;&lt;p&gt;下面是一个表示不可变二维整数点的类：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ... 其余部分省略&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设我们想扩展Point，增加颜色属性：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ColorPoint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;extends&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ... 其余部分省略&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时应该如何编写equals方法？如果忽略颜色属性，直接使用继承的equals方法，虽然并不违反equals约定，但显然这个结果也不是我们想要的。一种可能的equals写法是，仅当参数是另一个具有相同颜色和位置的&lt;code&gt;ColorPoint&lt;/code&gt;时才返回true：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="na"&gt;color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该实现的问题在于&lt;code&gt;Point&lt;/code&gt;和&lt;code&gt;ColorPoint&lt;/code&gt;的比较结果不同，前者会忽略颜色，而后者总是返回false（因为类型不匹配），具体来说：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;RED&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;p.equals(cp)&lt;/code&gt; 会返回true，而 &lt;code&gt;cp.equals(p)&lt;/code&gt; 却是返回false，很明显，这违反了对称性。&lt;/p&gt;&lt;p&gt;为了解决此问题，一种可能的做法是，当混合比较时，忽略颜色属性：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 如果 o 是一个普通的 Point，进行不区分颜色的比较&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 注意这里调用的是 Point 的 equals&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// o 是一个 ColorPoint；进行完整比较&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="na"&gt;color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遗憾的是，虽然这样做实现了对称性，但却违反了传递性！&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;RED&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;BLUE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 &lt;code&gt;p1.equals(p2)&lt;/code&gt; (调用 &lt;code&gt;ColorPoint.equals(Point)&lt;/code&gt;，忽略颜色) 和 &lt;code&gt;p2.equals(p3)&lt;/code&gt; (调用 &lt;code&gt;Point.equals(ColorPoint))&lt;/code&gt; 都返回 true，而 &lt;code&gt;p1.equals(p3)&lt;/code&gt; (调用 &lt;code&gt;ColorPoint.equals(ColorPoint)&lt;/code&gt;，比较颜色) 返回 false，这明显违反了传递性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那么解决方案是什么呢？&lt;/strong&gt; 事实证明，这是面向对象语言中等价关系的一个基本问题。没有办法在扩展一个可实例化的类并添加值组件的同时保留 equals 约定，除非你愿意放弃面向对象抽象的好处。&lt;/p&gt;&lt;p&gt;有人提出使用 &lt;code&gt;getClass&lt;/code&gt; 代替 &lt;code&gt;instanceof&lt;/code&gt; 检查，这样既保留了equals约定，又能在扩展可实例化类时添加值组件：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 错误！违反了里氏替换原则&lt;/span&gt;
&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClass&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getClass&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 使用 getClass&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种做法会导致只有相同实现类的对象才会被视为相等，咋一看好像没啥问题，但实际后果完全不可接受：&lt;code&gt;Point&lt;/code&gt; 子类的实例仍然是一个 &lt;code&gt;Point&lt;/code&gt;，并且它仍然需要像 &lt;code&gt;Point&lt;/code&gt; 一样工作，但如果采用这种方法，它就做不到！&lt;/p&gt;&lt;p&gt;里氏替换原则 (Liskov substitution principle) 指出，一个类型的所有重要属性也应该适用于其所有子类型，因此为该类型编写的任何方法都应该同样适用于其子类型。如果我们使用基于 &lt;code&gt;getClass&lt;/code&gt; 的 equals 方法，那么 &lt;code&gt;Point&lt;/code&gt; 的子类（例如 &lt;code&gt;CounterPoint&lt;/code&gt;，一个简单记录创建实例数量的 &lt;code&gt;Point&lt;/code&gt; 子类）将不等于任何 &lt;code&gt;Point&lt;/code&gt; 实例，即使它们的坐标相同。这会导致依赖 equals 的集合（如 HashSet）行为不正确。&lt;/p&gt;&lt;p&gt;虽然没有令人满意的方法来扩展一个可实例化的类并添加值组件，但有一个很好的 &lt;strong&gt;变通方法：遵循“组合优于继承”的建议。&lt;/strong&gt; 不要让 &lt;code&gt;ColorPoint&lt;/code&gt; 扩展 &lt;code&gt;Point&lt;/code&gt;，而是在 &lt;code&gt;ColorPoint&lt;/code&gt; 中包含一个私有的 &lt;code&gt;Point&lt;/code&gt; 字段，并提供一个公共的视图方法来返回该 &lt;code&gt;Point&lt;/code&gt;：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 在不违反 equals 约定的情况下添加值组件&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ColorPoint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Objects&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;requireNonNull&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * 返回此颜色点的点视图。&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;asPoint&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColorPoint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;point&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;color&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ... 其余部分省略&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;一致性&lt;/h3&gt;
&lt;p&gt;对于任何非空的引用值 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，只要equals比较过程中使用的信息没有被修改，多次调用 &lt;code&gt;x.equals(y)&lt;/code&gt; 必须始终返回true或false。&lt;/p&gt;&lt;p&gt;这意味着如果两个对象相等，它们必须始终相等，除非其中一个（或两个）被修改。换句话说，可变对象在不同时间可能等于不同的对象，而不可变对象则不能。&lt;/p&gt;&lt;p&gt;不要编写依赖于不可靠资源的 equals 方法。 例如，&lt;code&gt;java.net.URL&lt;/code&gt; 的 equals 方法依赖于比较与 URL 关联的主机的 IP 地址。将主机名转换为 IP 地址可能需要网络访问，并且不能保证随时间推移会产生相同的结果。这可能导致 &lt;code&gt;URL&lt;/code&gt; 的 equals 方法违反 equals 约定，并在实践中引发问题。equals 方法应该只对内存中的对象执行确定性计算。&lt;/p&gt;&lt;h3&gt;非空性&lt;/h3&gt;
&lt;p&gt;对于任何非空的引用值&lt;code&gt;x&lt;/code&gt;，&lt;code&gt;x.equals(null)&lt;/code&gt; 必须返回false。&lt;/p&gt;&lt;p&gt;equals 方法的通用约定禁止在与 null 比较时抛出 NullPointerException。许多类的 equals 方法通过显式测试 null 来防止这种情况：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该检查是不必要的，equals 方法必须首先将其参数转换为适当的类型才能调用其访问器或访问其字段。在进行强制转换之前，方法必须使用 &lt;code&gt;instanceof&lt;/code&gt; 运算符来检查其参数是否为正确的类型：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MyType&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// MyType 是你正在定义的类&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;MyType&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MyType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果其第一个操作数为 null，&lt;code&gt;instanceof&lt;/code&gt; 运算符会返回 false，而不管第二个操作数中出现什么类型。因此，如果传入 null，类型检查将返回 false，所以你不需要显式的 null 检查。&lt;/p&gt;&lt;h2&gt;实现高质量equals方法的诀窍&lt;/h2&gt;
&lt;p&gt;综合以上所有内容，这里有一个高质量 &lt;code&gt;equals&lt;/code&gt; 方法的实现步骤：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用 &lt;code&gt;==&lt;/code&gt; 运算符检查参数是否是此对象的引用。&lt;/strong&gt; 如果是，则返回 &lt;code&gt;true&lt;/code&gt;。这只是一种性能优化，但如果比较操作代价高昂时，则值得这样做。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用 &lt;code&gt;instanceof&lt;/code&gt; 运算符检查参数是否具有正确的类型。&lt;/strong&gt; 如果不是，则返回 &lt;code&gt;false&lt;/code&gt;。通常来说，正确的类型是指方法所在类，但有时也可能是此类实现的某个接口（如果该接口改进了 &lt;code&gt;equals&lt;/code&gt; 约定，以允许在实现了该接口的不同类之间进行比较，例如集合接口 &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;将参数强制转换为正确的类型。&lt;/strong&gt; 由于转换前使用了 &lt;code&gt;instanceof&lt;/code&gt; 进行类型检查 ，所以类型转换必定会成功。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;对于类中的每个“重要”字段，检查参数的该字段是否与此对象的相应字段匹配。&lt;/strong&gt; 如果所有这些比较都成功，则返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;对于类型不是 &lt;code&gt;float&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; 的基本类型字段，使用 &lt;code&gt;==&lt;/code&gt; 运算符进行比较。&lt;/li&gt;
&lt;li&gt;对于对象引用字段，递归调用 &lt;code&gt;equals&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;float&lt;/code&gt; 字段，使用 &lt;code&gt;Float.compare(float, float)&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;double&lt;/code&gt; 字段，使用 &lt;code&gt;Double.compare(double, double)&lt;/code&gt; 方法。（&lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 字段的特殊处理是由于存在 &lt;code&gt;Float.NaN&lt;/code&gt;, &lt;code&gt;-0.0f&lt;/code&gt; 以及类似的 &lt;code&gt;double&lt;/code&gt; 值）。&lt;/li&gt;
&lt;li&gt;对于数组字段，将这些准则应用于每个元素。如果数组字段中的每个元素都很重要，请使用 &lt;code&gt;Arrays.equals&lt;/code&gt; 方法之一。&lt;/li&gt;
&lt;li&gt;某些对象引用字段可能合法地包含 &lt;code&gt;null&lt;/code&gt;，为避免 &lt;code&gt;NullPointerException&lt;/code&gt; 的可能性，请使用静态方法 &lt;code&gt;Objects.equals(Object, Object)&lt;/code&gt; 检查此类字段是否相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了获得最佳性能，应首先比较更有可能不同、比较成本较低或理想情况下两者兼备的字段。不得比较不属于对象逻辑状态的字段（例如用于同步操作的锁字段）。&lt;/p&gt;&lt;h2&gt;示例：&lt;code&gt;PhoneNumber&lt;/code&gt; 类&lt;/h2&gt;
&lt;p&gt;下面是一个简单的 &lt;code&gt;PhoneNumber&lt;/code&gt; 类，它展示了一个典型的 &lt;code&gt;equals&lt;/code&gt; 方法实现：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PhoneNumber&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;final&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;areaCode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lineNum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;PhoneNumber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;areaCode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lineNum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;areaCode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rangeCheck&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;areaCode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;999&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;area code&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;prefix&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rangeCheck&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;999&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;prefix&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lineNum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rangeCheck&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lineNum&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9999&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;line num&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;rangeCheck&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IllegalArgumentException&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 步骤 1&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;instanceof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PhoneNumber&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 步骤 2&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PhoneNumber&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PhoneNumber&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 步骤 3&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 步骤 4&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lineNum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lineNum&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;prefix&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;areaCode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;areaCode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ... hashCode 和其他方法省略&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写完 &lt;code&gt;equals&lt;/code&gt; 方法后，问自己三个问题：它是否对称？是否具有传递性？是否一致？不能光问，还要编写单元测试来检查。&lt;/p&gt;&lt;h2&gt;最后几点注意事项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;重写 &lt;code&gt;equals&lt;/code&gt; 时必须重写 &lt;code&gt;hashCode&lt;/code&gt;&lt;/strong&gt;。这是 &lt;code&gt;hashCode&lt;/code&gt; 的通用约定要求的，否则你的类在与基于哈希的集合（如 &lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;HashSet&lt;/code&gt;）一起使用时将无法正常工作。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不要试图太聪明。&lt;/strong&gt; 如果你只是简单地测试字段的相等性，遵守 &lt;code&gt;equals&lt;/code&gt; 约定并不难。如果你在寻找等价性方面过于激进，就很容易陷入麻烦。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不要在 &lt;code&gt;equals&lt;/code&gt; 声明中用其他类型替换 &lt;code&gt;Object&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 错误示范 - 参数类型必须是 Object!&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// public boolean equals(MyClass o) { ... }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该写法的问题在于这个方法没有重写 &lt;code&gt;Object.equals&lt;/code&gt;（其参数类型是 &lt;code&gt;Object&lt;/code&gt;），而是重载了它。即使是除了正常的 &lt;code&gt;equals&lt;/code&gt; 方法之外，还提供这样一个“强类型”的 &lt;code&gt;equals&lt;/code&gt; 方法也是不可接受的。始终使用 &lt;code&gt;@Override&lt;/code&gt; 注解可以防止你犯这个错误：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 仍然是错误的，但编译器会报错&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// @Override public boolean equals(MyClass o) { ... }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;考虑使用工具库来生成 &lt;code&gt;equals&lt;/code&gt; (和 &lt;code&gt;hashCode&lt;/code&gt;)。&lt;/strong&gt; 像 Google 的 AutoValue 框架或 Lombok 这样的库可以自动为你生成这些方法，减少样板代码和出错的可能性。IDE 通常也提供生成这些方法的功能。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;除非必须，否则不要重写 &lt;code&gt;equals&lt;/code&gt; 方法：在许多情况下，从 &lt;code&gt;Object&lt;/code&gt; 继承的实现正是你想要的。如果你确实重写了 &lt;code&gt;equals&lt;/code&gt;，请确保比较类的所有重要字段，并以保留 &lt;code&gt;equals&lt;/code&gt; 约定的所有五个条款的方式进行比较。&lt;/p&gt;</description><author>im.wuxiaoyuan@gmail.com (wuxiaoyuan)</author><guid isPermaLink="true">/archives/high-quality-equals/</guid><pubDate>Thu, 05 Jun 2025 21:34:50 +0806</pubDate></item></channel></rss>